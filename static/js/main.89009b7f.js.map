{"version":3,"sources":["..\\static\\js\\main.89009b7f.js","..\\webpack\\bootstrap e2e24a5fde3fae499f35","..\\node_modules\\rot-js\\lib\\rot.js","const.js","entities.js","entity.js","game.js","xy.js","glyph.js","mixins.js","screens.js","tile.js","..\\node_modules\\promise\\lib\\core.js","..\\node_modules\\sprintf-js\\src\\sprintf.js","..\\node_modules\\webpack\\buildin\\global.js","..\\config\\polyfills.js","index.js","..\\node_modules\\asap\\browser-raw.js","map.js","mapgen.js","msg.js","..\\node_modules\\dice.js\\build\\dice.js","..\\node_modules\\object-assign\\index.js","..\\node_modules\\process\\browser.js","..\\node_modules\\promise\\lib\\es6-extensions.js","..\\node_modules\\promise\\lib\\rejection-tracking.js","..\\node_modules\\whatwg-fetch\\fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","process","requestAnimationFrame","cb","setTimeout","document","body","appendChild","child","scrollLeft","scrollTop","createElement","type","canvas","getBoundingClientRect","left","top","getContext","_termcolor","beginPath","clearRect","x","y","w","h","this","clearCmd","clearToAnsi","fillStyle","stdout","write","drawImage","a","b","e","f","g","fill","fillRect","fillText","chs","font","lineTo","measureText","ch","width","moveTo","textAlign","textBaseline","height","style","position","visibility","documentElement","ROT","isSupported","Function","bind","DEFAULT_WIDTH","DEFAULT_HEIGHT","DIRS","4","8","6","VK_CANCEL","VK_HELP","VK_BACK_SPACE","VK_TAB","VK_CLEAR","VK_RETURN","VK_ENTER","VK_SHIFT","VK_CONTROL","VK_ALT","VK_PAUSE","VK_CAPS_LOCK","VK_ESCAPE","VK_SPACE","VK_PAGE_UP","VK_PAGE_DOWN","VK_END","VK_HOME","VK_LEFT","VK_UP","VK_RIGHT","VK_DOWN","VK_PRINTSCREEN","VK_INSERT","VK_DELETE","VK_0","VK_1","VK_2","VK_3","VK_4","VK_5","VK_6","VK_7","VK_8","VK_9","VK_COLON","VK_SEMICOLON","VK_LESS_THAN","VK_EQUALS","VK_GREATER_THAN","VK_QUESTION_MARK","VK_AT","VK_A","VK_B","VK_C","VK_D","VK_E","VK_F","VK_G","VK_H","VK_I","VK_J","VK_K","VK_L","VK_M","VK_N","VK_O","VK_P","VK_Q","VK_R","VK_S","VK_T","VK_U","VK_V","VK_W","VK_X","VK_Y","VK_Z","VK_CONTEXT_MENU","VK_NUMPAD0","VK_NUMPAD1","VK_NUMPAD2","VK_NUMPAD3","VK_NUMPAD4","VK_NUMPAD5","VK_NUMPAD6","VK_NUMPAD7","VK_NUMPAD8","VK_NUMPAD9","VK_MULTIPLY","VK_ADD","VK_SEPARATOR","VK_SUBTRACT","VK_DECIMAL","VK_DIVIDE","VK_F1","VK_F2","VK_F3","VK_F4","VK_F5","VK_F6","VK_F7","VK_F8","VK_F9","VK_F10","VK_F11","VK_F12","VK_F13","VK_F14","VK_F15","VK_F16","VK_F17","VK_F18","VK_F19","VK_F20","VK_F21","VK_F22","VK_F23","VK_F24","VK_NUM_LOCK","VK_SCROLL_LOCK","VK_CIRCUMFLEX","VK_EXCLAMATION","VK_DOUBLE_QUOTE","VK_HASH","VK_DOLLAR","VK_PERCENT","VK_AMPERSAND","VK_UNDERSCORE","VK_OPEN_PAREN","VK_CLOSE_PAREN","VK_ASTERISK","VK_PLUS","VK_PIPE","VK_HYPHEN_MINUS","VK_OPEN_CURLY_BRACKET","VK_CLOSE_CURLY_BRACKET","VK_TILDE","VK_COMMA","VK_PERIOD","VK_SLASH","VK_BACK_QUOTE","VK_OPEN_BRACKET","VK_BACK_SLASH","VK_CLOSE_BRACKET","VK_QUOTE","VK_META","VK_ALTGR","VK_WIN","VK_KANA","VK_HANGUL","VK_EISU","VK_JUNJA","VK_FINAL","VK_HANJA","VK_KANJI","VK_CONVERT","VK_NONCONVERT","VK_ACCEPT","VK_MODECHANGE","VK_SELECT","VK_PRINT","VK_EXECUTE","VK_SLEEP","Text","RE_COLORS","TYPE_TEXT","TYPE_NEWLINE","TYPE_FG","TYPE_BG","measure","str","maxWidth","result","tokens","tokenize","lineWidth","length","token","Math","max","offset","replace","match","index","part","substring","push","trim","_breakLines","Infinity","lineLength","lastTokenWithSpace","charAt","indexOf","_breakInsideToken","arr","split","pop","join","nextIndex","breakIndex","lastIndexOf","splice","lastTextToken","tokenIndex","removeBreakChar","newBreakToken","newTextToken","Array","random","floor","RNG","getUniform","randomize","Number","mod","String","capitalize","toUpperCase","lpad","character","count","cnt","rpad","format","template","map","args","slice","arguments","replacer","group1","group2","obj","group","parts","shift","method","toLowerCase","replaced","apply","first","unshift","create","tmp","extend","parent","constructor","window","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","Display","options","_context","_data","_dirty","_options","_backend","defaultOptions","transpose","layout","fontSize","spacing","border","forceSquareRatio","fontFamily","fontStyle","fg","bg","tileWidth","tileHeight","tileMap","tileSet","tileColorize","termColor","setOptions","DEBUG","_tick","what","colors","draw","clear","compute","getOptions","getContainer","computeSize","availWidth","availHeight","computeFontSize","eventToPosition","touches","clientX","clientY","rect","drawText","text","cx","cy","lines","isSpace","isPrevSpace","isFullWidth","isPrevFullWidth","cc","charCodeAt","_draw","key","clearBefore","data","Backend","context","Rect","_spacingX","_spacingY","_canvasCache","cache","charWidth","ceil","_drawWithCache","_drawNoCache","hash","ctx","chars","concat","boxWidth","boxHeight","oldFont","ratio","widthFraction","Hex","_hexSize","sqrt","xprop","yprop","px","reverse","_fill","hexSizeWidth","hexSizeHeight","hexSize","min","prop","size","Tile","_colorCanvas","tile","Error","globalCompositeOperation","getSeed","_seed","setSeed","seed","_s0","_frac","_s1","_s2","_c","t","getUniformInt","lowerBound","upperBound","getNormal","mean","stddev","u","v","r","gauss","log","getPercentage","getWeightedValue","total","getState","setState","state","clone","Date","now","StringGenerator","words","order","prior","_boundary","fromCharCode","_suffix","_prefix","_priorValues","generate","_sample","_join","observe","string","_split","event","j","subcontext","_observeEvent","getStats","priorCount","dataCount","eventCount","_backoff","available","EventQueue","_time","_events","_eventTimes","getTime","add","time","remove","_remove","Scheduler","_queue","_repeat","_current","item","repeat","next","Simple","Speed","getSpeed","Action","_defaultDuration","_duration","setDuration","Engine","scheduler","_scheduler","_lock","start","unlock","lock","actor","act","then","Map","_width","_height","callback","_fillMap","Arena","empty","DividedMaze","_stack","_map","_process","room","_partitionRoom","availX","availY","bottom","right","walls","solid","hole","IceyMaze","regularity","_regularity","nx","ny","done","blocked","dirs","_randomize","_isFree","EllerMaze","L","R","_addToList","_removeFromList","Cellular","born","survive","topology","connected","_dirs","probability","set","newMap","widthStep","widthStart","cur","ncount","_getNeighbors","_completeMaze","dir","allFreeSpace","notConnected","_freeSpace","_pointKey","_findConnected","keys","_getFromTo","from","to","local","_tunnelToConnected","k","pp","connectedKeys","notConnectedKeys","_getClosest","point","space","minPoint","minDist","stack","keepNotConnected","tests","xx","pkey","yy","Dungeon","_rooms","_corridors","getRooms","getCorridors","Digger","roomWidth","roomHeight","corridorLength","dugPercentage","timeLimit","_features","Room","Corridor","_featureAttempts","_walls","_digCallback","_canBeDugCallback","_isWallCallback","_priorityWallCallback","_dug","area","_firstRoom","t1","wall","_findWall","parseInt","_getDiggingDirection","featureAttempts","_tryFeature","_removeSurroundingWalls","priorityWalls","_addDoors","Feature","createRandomCenter","prio1","prio2","dx","dy","feature","createRandomAt","isValid","createPriorityWalls","deltas","delta","isWallCallback","clearDoors","addDoors","Uniform","roomDugPercentage","_roomAttempts","_corridorAttempts","_connected","_unconnected","_generateRooms","_generateCorridors","_generateRoom","createRandom","room1","_closestRoom","room2","_connectRooms","rooms","dist","center","getCenter","center1","center2","diffX","diffY","abs","dirIndex1","dirIndex2","getLeft","getRight","getTop","getBottom","_placeInWall","end","_digLine","diff","rotation","mid","index2","round","mid1","mid2","addDoor","dirIndex","avail","lastBadIndex","points","corridor","Rogue","cellWidth","cellHeight","_calculateRoomSize","connectedCells","_initRooms","_connectUnconnectedRooms","_createRandomRoomConnections","_createRooms","_createCorridors","cell","connections","cellx","celly","idx","ncgx","ncgy","otherRoom","cgx","cgy","found","dirToCheck","cw","validRoom","directions","dirIdx","newI","newJ","console","roomw","roomh","sx","sy","cwp","chp","sxOffset","syOffset","ii","jj","_getWallPosition","aRoom","aDirection","rx","ry","door","_drawCorridore","startPosition","endPosition","tempDist","xDir","yDir","move","xOffset","yOffset","xpos","ypos","moves","xAbs","yAbs","percent","firstHalf","secondHalf","connection","otherWall","canBeDugCallback","digCallback","debug","x1","y1","x2","y2","doorX","doorY","_x1","_y1","_x2","_y2","_doors","getDoors","startX","startY","endX","endY","_startX","_startY","_endX","_endY","_endsWithAWall","ok","firstCornerBad","secondCornerBad","priorityWallCallback","Noise","Simplex","gradients","_F2","_G2","_gradients","permutations","_perms","_indexes","xin","yin","gi","i1","j1","perms","indexes","G2","n0","n1","n2","X0","Y0","x0","y0","t0","grad","t2","FOV","lightPassesCallback","_lightPasses","_getCircle","countFactor","startOffset","DiscreteShadowcasting","_coords","A","B","blocks","DATA","neighbors","angle","_visibleCoords","v1","callee","v2","PreciseShadowcasting","A1","A2","SHADOWS","neighborCount","_checkVisibility","index1","edge1","old","edge2","visible","visibleLength","P","P1","P2","RecursiveShadowcasting","OCTANTS","_renderOctant","compute180","previousOctant","nextPreviousOctant","nextOctant","compute90","octant","_castVisibility","row","visSlopeStart","visSlopeEnd","radius","xy","yx","newStart","mapX","mapY","slopeStart","slopeEnd","Color","fromString","cached","_cache","values","color1","color2","add_","multiply","multiply_","interpolate","factor","interpolateHSL","hsl1","rgb2hsl","hsl2","hsl2rgb","color","hue2rgb","q","toRGB","_clamp","toHex","toString","num","black","navy","darkblue","mediumblue","blue","darkgreen","green","teal","darkcyan","deepskyblue","darkturquoise","mediumspringgreen","lime","springgreen","aqua","cyan","midnightblue","dodgerblue","forestgreen","seagreen","darkslategray","darkslategrey","limegreen","mediumseagreen","turquoise","royalblue","steelblue","darkslateblue","mediumturquoise","indigo","darkolivegreen","cadetblue","cornflowerblue","mediumaquamarine","dimgray","dimgrey","slateblue","olivedrab","slategray","slategrey","lightslategray","lightslategrey","mediumslateblue","lawngreen","chartreuse","aquamarine","maroon","purple","olive","gray","grey","skyblue","lightskyblue","blueviolet","darkred","darkmagenta","saddlebrown","darkseagreen","lightgreen","mediumpurple","darkviolet","palegreen","darkorchid","yellowgreen","sienna","brown","darkgray","darkgrey","lightblue","greenyellow","paleturquoise","lightsteelblue","powderblue","firebrick","darkgoldenrod","mediumorchid","rosybrown","darkkhaki","silver","mediumvioletred","indianred","peru","chocolate","tan","lightgray","lightgrey","palevioletred","thistle","orchid","goldenrod","crimson","gainsboro","plum","burlywood","lightcyan","lavender","darksalmon","violet","palegoldenrod","lightcoral","khaki","aliceblue","honeydew","azure","sandybrown","wheat","beige","whitesmoke","mintcream","ghostwhite","salmon","antiquewhite","linen","lightgoldenrodyellow","oldlace","red","fuchsia","magenta","deeppink","orangered","tomato","hotpink","coral","darkorange","lightsalmon","orange","lightpink","pink","gold","peachpuff","navajowhite","moccasin","bisque","mistyrose","blanchedalmond","papayawhip","lavenderblush","seashell","cornsilk","lemonchiffon","floralwhite","snow","yellow","lightyellow","ivory","white","Lighting","reflectivityCallback","_reflectivityCallback","passes","emissionThreshold","range","_fov","_lights","_reflectivityCache","_fovCache","reset","setFOV","fov","setLight","clearLights","lightingCallback","doneCells","emittingCells","litCells","light","_emitLight","_computeEmitters","litKey","_emitLightFromCell","reflectivity","emission","intensity","_updateFOV","fovKey","formFactor","key1","vis","key2","Path","toX","toY","passableCallback","_toX","_toY","_fromX","_fromY","_passableCallback","fromX","fromY","Dijkstra","_computed","_todo","_add","_compute","prev","neighbor","AStar","_done","_distance","Term","_cx","_cy","_lastColor","_ox","_oy","columns","rows","positionToAnsi","newColor","colorToAnsi","Xterm","rgb","__webpack_exports__","DisplayOptions","MapOptions","Tiles","null","chr","foreground","background","isWalkable","isDiggable","PlayerTemplate","FungusTemplate","EnemyTemplate","__WEBPACK_IMPORTED_MODULE_0__mixins__","maxHp","attackValue","mixins","Moveable","PlayerActor","Attacker","Destructible","MessageRecipient","FungusActor","EnemyActor","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__glyph__","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","Entity","_Glyph","properties","undefined","_this","getPrototypeOf","attachedMixins","attachedMixinGroups","groupName","init","__WEBPACK_IMPORTED_MODULE_0_rot_js__","__WEBPACK_IMPORTED_MODULE_0_rot_js___default","__WEBPACK_IMPORTED_MODULE_1__screens__","__WEBPACK_IMPORTED_MODULE_2__const__","Game","currentScreen","display","addEventListener","handleInput","switchScreen","startScreen","screen","exit","enter","refresh","render","game","XY","Glyph","__WEBPACK_IMPORTED_MODULE_1__xy__","__WEBPACK_IMPORTED_MODULE_2__game__","__WEBPACK_IMPORTED_MODULE_3__entity__","__WEBPACK_IMPORTED_MODULE_4__entities__","__WEBPACK_IMPORTED_MODULE_6_dice_js__","__WEBPACK_IMPORTED_MODULE_6_dice_js___default","__WEBPACK_IMPORTED_MODULE_7__msg__","Mixins","tryMove","getTile","getEntityAt","hasMixin","attack","dig","defenseValue","hp","takeDamage","attacker","damage","engine","removeEntity","SimpleAttacker","roll","clearMessages","growthsRemaining","lifeTurns","xyOffset","is","xyLoc","plus","isEmptyFloor","entity","addEntity","entities","astar","path","pathCallback","Teleportable","teleport","getRandomFloorTile","messages","receiveMessage","message","__WEBPACK_IMPORTED_MODULE_1__game__","__WEBPACK_IMPORTED_MODULE_2__mapgen__","__WEBPACK_IMPORTED_MODULE_3__const__","__WEBPACK_IMPORTED_MODULE_4__xy__","__WEBPACK_IMPORTED_MODULE_5__entity__","__WEBPACK_IMPORTED_MODULE_6__entities__","__WEBPACK_IMPORTED_MODULE_7_sprintf_js__","__WEBPACK_IMPORTED_MODULE_7_sprintf_js___default","vsprintf","Screen","sprintf","inputType","inputData","keyCode","playScreen","player","distance","newXY","screenWidth","screenHeight","topLeftX","topLeftY","stats","winScreen","loseScreen","direction","__WEBPACK_IMPORTED_MODULE_1__const__","noop","getThen","ex","LAST_ERROR","IS_ERROR","tryCallOne","fn","tryCallTwo","Promise","_45","_81","_65","_54","doResolve","safeThen","onFulfilled","onRejected","resolve","reject","res","handle","Handler","deferred","_10","handleResolved","asap","promise","ret","newValue","finale","_97","reason","_61","__WEBPACK_AMD_DEFINE_RESULT__","sprintf_format","sprintf_parse","fmt","argv","parse_tree","arg","pad","pad_character","pad_length","is_positive","sign","cursor","tree_length","output","isArray","re","not_type","test","not_primitive","numeric_arg","isNaN","number","JSON","stringify","parseFloat","toExponential","toFixed","toPrecision","valueOf","json","sprintf_cache","_fmt","arg_names","exec","modulo","placeholder","SyntaxError","field_list","replacement_field","field_match","key_access","index_access","not_string","not_bool","not_json","eval","enable","assign","alert","rawAsap","task","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromTimer","handleTimer","timeoutHandle","clearInterval","intervalHandle","setInterval","scope","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","toggle","observer","node","createTextNode","characterData","__WEBPACK_IMPORTED_MODULE_1__tile__","__WEBPACK_IMPORTED_MODULE_2__xy__","tiles","_initialiseProps","addEntityAtRandomPosition","isInBounds","getEntitiesWithinRadius","centerXY","results","leftX","rightX","topY","bottomY","GenerateMap","__WEBPACK_IMPORTED_MODULE_3__tile__","__WEBPACK_IMPORTED_MODULE_1__map__","sendMessage","recipient","__WEBPACK_IMPORTED_MODULE_0__mixins_js__","sendMessageNearby","__WEBPACK_IMPORTED_MODULE_1_sprintf_js__","__WEBPACK_IMPORTED_MODULE_1_sprintf_js___default","require","code","1","version","description","main","directories","dependencies","devDependencies","browserify","jasmine-core","jasmine-node","karma","karma-chrome-launcher","karma-firefox-launcher","karma-jasmine","karma-phantomjs-launcher","pegjs","scripts","repository","url","keywords","author","license","bugs","homepage","2","parsed","dice","parse","determine_min_max_possible","opObject","op","lookup","ops","minmax","multipleMinMax","randPartMinMax","minMinMax","maxMinMax","leftMinMax","rightMinMax","stringify_expression","evaled_op","sub","expression","prefix","stringify_op","rs","rightSide","ls","leftSide","stringify_rolls","evaled_roll","minStr","mode","rolls","evaled","statistics","samples","resultSet","reduce","acc","minMaxPossible","min_possible","max_possible","../package","./evaluate","./parser","3","makeSeq","endIndex","seq","resolve_ops","resolve_op","opObj","subArgs","static","outValue","variableName","out","undef","reduceRes","elem","floorable","tots","ceilable","roundable","numRolls","minMax","outMin","outMax","rolled","rolledRet","sum","val","lastRolled","wildrolled","mimMax","minFun","maxFun","rawRandom","rndNumber","+","-","*","/","paren_express","outtots","peg$SyntaxError","expected","location","captureStackTrace","peg$parse","input","peg$literalExpectation","ignoreCase","peg$classExpectation","inverted","peg$otherExpectation","peg$computePosDetails","pos","details","peg$posDetailsCache","line","column","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$currPos","peg$maxFailPos","peg$maxFailExpected","peg$buildStructuredError","buildMessage","peg$parsestart","peg$parsedicerolls","s0","s1","s2","s3","peg$parsemultiplicationSeq","peg$FAILED","peg$parseadditionOp","peg$parseadditionSeq","peg$savedPos","peg$c0","peg$c1","peg$parseparenExpress","s4","s5","peg$c2","peg$silentFails","peg$c3","peg$parsews","peg$c4","peg$c5","peg$c6","peg$parsemultiplicationOp","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$parsediceroll","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$parseintval","peg$parserollmode","peg$parsemaybe_minmax","peg$c24","peg$c25","peg$parseminmax","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","substr","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$parseinteger","peg$c39","peg$parselookup","peg$c40","peg$parsemathit","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$parsevariable","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c61","peg$c62","peg$c63","peg$c64","peg$c60","peg$result","peg$startRuleFunctions","peg$startRuleFunction","paren","mm","varname","digits","startRule","ctor","hex","literalEscape","classEscape","describeExpectation","expectation","DESCRIBE_EXPECTATION_FNS","literal","class","escapedParts","any","other","descriptions","sort","toObject","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","test1","getOwnPropertyNames","test2","test3","forEach","letter","err","source","symbols","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","remaining","race","disable","enabled","onUnhandled","allRejections","matchWhitelist","rejections","error","whitelist","DEFAULT_WHITELIST","displayId","logged","logError","onHandled","warn","_72","list","some","cls","RangeError","normalizeName","normalizeValue","iteratorFor","items","support","iterable","Headers","headers","append","header","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","bufferClone","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","rejected","decode","normalizeMethod","upcased","methods","Request","credentials","referrer","form","bytes","decodeURIComponent","parseHeaders","rawHeaders","Response","bodyInit","status","statusText","fetch","viewClasses","DataView","isView","oldValue","has","thisArg","entries","response","redirectStatuses","redirect","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"static/js/main.89009b7f.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dung/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 25);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(21)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DisplayOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MapOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return Tiles; });\nvar DisplayOptions = {\n    width: 80,\n    height: 25\n};\n\nvar MapOptions = {\n    width: 160,\n    height: 50\n};\n\nvar Tiles = {\n    \"null\": {},\n    floor: {\n        chr: \".\",\n        foreground: \"#444\",\n        background: \"#222\",\n        isWalkable: true\n    },\n    wall: {\n        chr: \"#\",\n        foreground: \"#777\",\n        background: \"#2e2e2e\",\n        isDiggable: true\n    }\n};\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PlayerTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return FungusTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return EnemyTemplate; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins__ = __webpack_require__(7);\n\n\n// Player template\nvar PlayerTemplate = {\n    chr: '@',\n    foreground: 'white',\n    background: 'black',\n    maxHp: 40,\n    attackValue: \"2d6\",\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Moveable, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].PlayerActor, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Attacker, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Destructible, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].MessageRecipient]\n};\n\n// Fungus template\nvar FungusTemplate = {\n    chr: 'F',\n    foreground: 'green',\n    name: \"fungus\",\n    maxHp: 10,\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].FungusActor, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Destructible]\n};\n\nvar EnemyTemplate = {\n    chr: '☹',\n    foreground: 'red',\n    name: \"most evil creature in the world\",\n    maxHp: 20,\n    attackValue: \"3d3\",\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Moveable, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].EnemyActor, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Attacker, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Destructible]\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__glyph__ = __webpack_require__(6);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar Entity = function (_Glyph) {\n    _inherits(Entity, _Glyph);\n\n    function Entity() {\n        var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Entity);\n\n        var _this = _possibleConstructorReturn(this, (Entity.__proto__ || Object.getPrototypeOf(Entity)).call(this, properties));\n\n        _this.name = properties[\"name\"] || \"\";\n        _this.xy = properties[\"xy\"] || 0;\n        _this.map = null;\n        // Create an object which will keep track what mixins we have\n        // attached to this entity based on the name property\n        _this.attachedMixins = {};\n        // Create a similar object for groups\n        _this.attachedMixinGroups = {};\n        // Setup the object's mixins\n        var mixins = properties['mixins'] || [];\n        for (var i = 0; i < mixins.length; i++) {\n            // Copy over all properties from each mixin as long\n            // as it's not the name or the init property. We\n            // also make sure not to override a property that\n            // already exists on the entity.\n            for (var key in mixins[i]) {\n                if (key !== 'init' && key !== 'name' && !_this.hasOwnProperty(key)) {\n                    _this[key] = mixins[i][key];\n                }\n            }\n            // Add the name of this mixin to our attached mixins\n            _this.attachedMixins[mixins[i].name] = true;\n            // If a group name is present, add it\n            if (mixins[i].groupName) {\n                _this.attachedMixinGroups[mixins[i].groupName] = true;\n            }\n            // Finally call the init function if there is one\n            if (mixins[i].init) {\n                mixins[i].init.call(_this, properties);\n            }\n        }\n        return _this;\n    }\n\n    _createClass(Entity, [{\n        key: \"hasMixin\",\n        value: function hasMixin(obj) {\n            // Allow passing the mixin itself or the name / group name as a string\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n                return this.attachedMixins[obj.name];\n            } else {\n                return this.attachedMixins[obj] || this.attachedMixinGroups[obj];\n            }\n        }\n    }]);\n\n    return Entity;\n}(__WEBPACK_IMPORTED_MODULE_0__glyph__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Entity);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__screens__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__const__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar Game = function () {\n    function Game() {\n        _classCallCheck(this, Game);\n\n        this.currentScreen = null;\n    }\n\n    _createClass(Game, [{\n        key: 'init',\n        value: function init() {\n            var _this = this;\n\n            // Initialize display\n            this.display = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Display(__WEBPACK_IMPORTED_MODULE_2__const__[\"a\" /* DisplayOptions */]);\n            // Append display to the document (HTML file)\n            // This creates an <canvas> in the document\n            document.body.appendChild(this.display.getContainer());\n            // Helper function\n            var bindEventToScreen = function bindEventToScreen(event) {\n                window.addEventListener(event, function (e) {\n                    // When an event is received, send it to the\n                    // screen if there is one\n                    if (_this.currentScreen !== null) {\n                        // Send the event type and data to the screen\n                        _this.currentScreen.handleInput(event, e);\n                    }\n                });\n            };\n            // Bind keyboard input events\n            bindEventToScreen('keydown');\n            // bindEventToScreen('keyup');\n            // bindEventToScreen('keypress');\n            this.switchScreen(__WEBPACK_IMPORTED_MODULE_1__screens__[\"a\" /* default */].startScreen);\n        }\n    }, {\n        key: 'switchScreen',\n        value: function switchScreen(screen) {\n            // If we had a screen before, notify it that we exited\n            if (this.currentScreen !== null) {\n                this.currentScreen.exit();\n            }\n            // Clear the display\n            this.display.clear();\n            // Update our current screen, notify it we entered\n            // and then render it\n            this.currentScreen = screen;\n            if (this.currentScreen) {\n                this.currentScreen.enter();\n                this.refresh();\n            }\n        }\n    }, {\n        key: 'refresh',\n        value: function refresh() {\n            // Clear the screen\n            this.display.clear();\n            // Render the screen\n            this.currentScreen.render(this.display);\n        }\n    }]);\n\n    return Game;\n}();\n\nvar game = new Game();\n/* harmony default export */ __webpack_exports__[\"a\"] = (game);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XY = function () {\n\tfunction XY() {\n\t\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t_classCallCheck(this, XY);\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t_createClass(XY, [{\n\t\tkey: \"toString\",\n\t\tvalue: function toString() {\n\t\t\treturn this.x + \",\" + this.y;\n\t\t}\n\t}, {\n\t\tkey: \"is\",\n\t\tvalue: function is(xy) {\n\t\t\treturn this.x === xy.x && this.y === xy.y;\n\t\t}\n\t}, {\n\t\tkey: \"dist8\",\n\t\tvalue: function dist8(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\n\t\t}\n\t}, {\n\t\tkey: \"dist4\",\n\t\tvalue: function dist4(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.abs(dx) + Math.abs(dy);\n\t\t}\n\t}, {\n\t\tkey: \"dist\",\n\t\tvalue: function dist(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t}, {\n\t\tkey: \"plus\",\n\t\tvalue: function plus(xy) {\n\t\t\treturn new XY(this.x + xy.x, this.y + xy.y);\n\t\t}\n\t}, {\n\t\tkey: \"minus\",\n\t\tvalue: function minus(xy) {\n\t\t\treturn new XY(this.x - xy.x, this.y - xy.y);\n\t\t}\n\t}]);\n\n\treturn XY;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XY);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// This class is needed to make coloured characters with coloured background.\nvar Glyph = function Glyph() {\n    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Glyph);\n\n    this.chr = properties[\"chr\"] || \"\";\n    this.foreground = properties[\"foreground\"] || \"#ccc\";\n    this.background = properties[\"background\"] || null;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Glyph);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__xy__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__game__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__entity__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__entities__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__screens__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_dice_js__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_dice_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_dice_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__msg__ = __webpack_require__(18);\n\n\n\n\n\n\n\n\n\n// Create our Mixins namespace\nvar Mixins = {};\n\n// Define our Moveable mixin\nMixins.Moveable = {\n    name: 'Moveable',\n    tryMove: function tryMove(xy, map) {\n        var tile = map.getTile(xy);\n        // If an entity was present at the tile\n        var target = map.getEntityAt(xy);\n        if (target) {\n            // If we are an attacker, try to attack\n            // the target\n            if (this.hasMixin('Attacker')) {\n                this.attack(target);\n                return true;\n            } else {\n                // If not nothing we can do, but we can't\n                // move to the tile\n                return false;\n            }\n        }\n        // Check if we can walk on the tile\n        // and if so simply walk onto it\n        if (tile.isWalkable) {\n            // Update the entity's position\n            this.xy = xy;\n            return true;\n            // Check if the tile is diggable, and\n            // if so try to dig it\n        } else if (tile.isDiggable) {\n            map.dig(xy);\n            return true;\n        }\n        return false;\n    }\n};\n\nMixins.Destructible = {\n    name: 'Destructible',\n    init: function init() {\n        var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { \"maxHp\": 10, \"defenseValue\": 0 };\n\n        this.maxHp = template[\"maxHp\"] || 10;\n        // We allow taking in health from the template incase we want\n        // the entity to start with a different amount of HP than the\n        // max specified.\n        this.hp = template[\"hp\"] || this.maxHp;\n        this.defenseValue = template[\"defenseValue\"] || 0;\n    },\n    takeDamage: function takeDamage(attacker, damage) {\n        this.hp -= damage;\n        // If have 0 or less HP, then remove ourselves from the map\n        if (this.hp <= 0) {\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__msg__[\"a\" /* sendMessage */])(attacker, 'You kill the %s!', [this.name]);\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__msg__[\"a\" /* sendMessage */])(this, 'You die!');\n            if (this.hasMixin(\"PlayerActor\")) {\n                // If ourself is player\n                this.map.engine.lock();\n                // game.switchScreen(Screen.loseScreen); // Show Game Over screen\n            }\n            this.map.removeEntity(this);\n        }\n    }\n};\n\nMixins.SimpleAttacker = {\n    name: 'SimpleAttacker',\n    groupName: 'Attacker',\n    attack: function attack(target) {\n        // Only remove the entity if they were attackable\n        if (target.hasMixin('Destructible')) {\n            target.takeDamage(this, 1);\n        }\n    }\n};\n\nMixins.Attacker = {\n    name: 'Attacker',\n    groupName: 'Attacker',\n    init: function init() {\n        var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { \"attackValue\": \"1d1\" };\n\n        this.attackValue = template[\"attackValue\"] || \"1d1\";\n    },\n    attack: function attack(target) {\n        // Only remove the entity if they were attackable\n        if (target.hasMixin('Destructible')) {\n            var damage = Math.max(0, __WEBPACK_IMPORTED_MODULE_6_dice_js___default.a.roll(this.attackValue) - target.defenseValue);\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__msg__[\"a\" /* sendMessage */])(this, 'You strike the %s for %d damage!', [target.name, damage]);\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__msg__[\"a\" /* sendMessage */])(target, 'The %s strikes you for %d damage!', [this.name, damage]);\n            target.takeDamage(this, damage);\n        }\n    }\n};\n\nMixins.PlayerActor = {\n    name: 'PlayerActor',\n    groupName: 'Actor',\n    act: function act() {\n        // Re-render the screen\n        __WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].refresh();\n        // Lock the engine and wait asynchronously\n        // for the player to press a key.\n        this.map.engine.lock();\n        // Clear the message queue\n        this.clearMessages();\n    }\n};\n\nMixins.FungusActor = {\n    name: 'FungusActor',\n    groupName: 'Actor',\n    init: function init() {\n        this.growthsRemaining = 5;\n        this.lifeTurns = 1000;\n    },\n    act: function act() {\n        this.lifeTurns--;\n        if (this.lifeTurns === 100) {\n            this.foreground = \"goldenrod\";\n        }\n        if (this.lifeTurns <= 0) {\n            this.map.removeEntity(this); // fungi die if they are too old\n        }\n        if (this.growthsRemaining <= 0 || Math.random() > 0.02) {\n            return;\n        }\n        // Generate the coordinates of a random adjacent square by\n        // generating an offset between [-1, 0, 1] for both the x and\n        // y directions. To do this, we generate a number from 0-2 and then\n        // subtract 1.\n        var xyOffset = new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](Math.floor(Math.random() * 3) - 1, Math.floor(Math.random() * 3) - 1);\n\n        // Make sure we aren't trying to spawn on the same tile as us\n        if (xyOffset.is(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */]())) {\n            return;\n        }\n\n        var xyLoc = this.xy.plus(xyOffset);\n\n        // Check if we can actually spawn at that location, and if so\n        // then we grow!\n        if (!this.map.isEmptyFloor(xyLoc)) {\n            return;\n        }\n\n        var entity = new __WEBPACK_IMPORTED_MODULE_3__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__entities__[\"b\" /* FungusTemplate */]);\n        entity.xy = xyLoc;\n        this.map.addEntity(entity);\n        this.growthsRemaining--;\n        // Send a message nearby!\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__msg__[\"b\" /* sendMessageNearby */])(this.map, entity.xy, 'The fungus is spreading!');\n    }\n};\n\nMixins.EnemyActor = {\n    name: 'EnemyActor',\n    groupName: 'Actor',\n    act: function act() {\n        var _this = this;\n\n        if (!this.map.entities[0]) {\n            return;\n        }\n        var x = this.map.entities[0].xy.x;\n        var y = this.map.entities[0].xy.y;\n        var passableCallback = function passableCallback(x, y) {\n            return _this.map.getTile(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y)).isWalkable;\n        }; // this.map.isEmptyFloor(new XY(x, y));\n        var astar = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Path.AStar(x, y, passableCallback);\n\n        var path = [];\n        var pathCallback = function pathCallback(x, y) {\n            return path.push(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y));\n        };\n        astar.compute(this.xy.x, this.xy.y, pathCallback);\n        x = path[1].x;\n        y = path[1].y;\n        this.tryMove(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y), this.map);\n    }\n};\n\nMixins.Teleportable = {\n    name: 'Teleportable',\n    teleport: function teleport(map) {\n        this.xy = map.getRandomFloorTile();\n        return true;\n    }\n};\n\nMixins.MessageRecipient = {\n    name: 'MessageRecipient',\n    init: function init(template) {\n        this.messages = [];\n    },\n    receiveMessage: function receiveMessage(message) {\n        this.messages.push(message);\n    },\n    clearMessages: function clearMessages() {\n        this.messages = [];\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Mixins);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapgen__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__const__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__xy__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__entity__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__entities__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sprintf_js__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sprintf_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_sprintf_js__);\nvar _this = this;\n\n//  How to make a screen\n//\n//  Screen.name {\n//      enter: () => {\n//          ...\n//      },\n//      exit: () => {\n//          ...\n//      },\n//      render: (display) => {\n//          ...\n//      },\n//      handleInput: (inputType, inputData) => {\n//          ...\n//      },\n//  }\n\n\n\n\n\n\n\n\n\n\nvar vsprintf = __WEBPACK_IMPORTED_MODULE_7_sprintf_js___default.a.vsprintf;\nvar sprintf = __WEBPACK_IMPORTED_MODULE_7_sprintf_js___default.a.sprintf;\n\nvar Screen = {};\n\n// Define our initial start screen\nScreen.startScreen = {\n    enter: function enter() {\n        console.log(\"Entered start screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited start screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        display.drawText(1, 1, \"%c{yellow}Javascript Roguelike\");\n        display.drawText(1, 2, \"Press [Enter] to start!\");\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // When [Enter] is pressed, go to the play screen\n        if (inputType === 'keydown') {\n            if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RETURN) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.playScreen);\n            }\n        }\n    }\n};\n\n// Define our playing screen\nScreen.playScreen = {\n    map: null,\n    player: null,\n    enter: function enter() {\n        // Keys for key handling\n        _this.keys = {};\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_K] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_UP] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD8] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_U] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD9] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PAGE_UP] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_L] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RIGHT] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD6] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_N] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD3] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PAGE_DOWN] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_J] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_DOWN] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD2] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_B] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD1] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_END] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_H] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_LEFT] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD4] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_Y] = 7;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD7] = 7;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_HOME] = 7;\n\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PERIOD] = -1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_CLEAR] = -1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD5] = -1;\n        _this.move = function (distance) {\n            var newXY = _this.player.xy.plus(distance);\n            // Try to move to the new cell\n            _this.player.tryMove(newXY, _this.map);\n        };\n        _this.player = new __WEBPACK_IMPORTED_MODULE_5__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_6__entities__[\"a\" /* PlayerTemplate */]);\n        _this.map = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__mapgen__[\"a\" /* default */])(_this.player);\n        _this.map.engine.start();\n        console.log(\"Entered play screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited play screen.\");\n    },\n    render: function render(display) {\n        var screenWidth = __WEBPACK_IMPORTED_MODULE_3__const__[\"a\" /* DisplayOptions */].width;\n        var screenHeight = __WEBPACK_IMPORTED_MODULE_3__const__[\"a\" /* DisplayOptions */].height;\n        // Make sure the x-axis doesn't go to the left of the left bound\n        var topLeftX = Math.max(0, _this.player.xy.x - screenWidth / 2);\n        // Make sure we still have enough space to fit an entire game screen\n        topLeftX = Math.floor(Math.min(topLeftX, _this.map.width - screenWidth));\n        // Make sure the y-axis doesn't above the top bound\n        var topLeftY = Math.max(0, _this.player.xy.y - screenHeight / 2);\n        // Make sure we still have enough space to fit an entire game screen\n        topLeftY = Math.floor(Math.min(topLeftY, _this.map.height - screenHeight));\n        // Iterate through all visible map cells\n        for (var x = topLeftX; x < topLeftX + screenWidth; x++) {\n            for (var y = topLeftY; y < topLeftY + screenHeight; y++) {\n                // Fetch the glyph for the tile and render it to the screen\n                // at the offset position.\n                var tile = _this.map.getTile(new __WEBPACK_IMPORTED_MODULE_4__xy__[\"a\" /* default */](x, y));\n                display.draw(x - topLeftX, y - topLeftY, tile.chr, tile.foreground, tile.background);\n            }\n        }\n        // Render the entities\n        var entities = _this.map.entities;\n        for (var i = 0; i < entities.length; i++) {\n            var entity = entities[i];\n            // Only render the entity if they would show up on the screen\n            if (entity.xy.x >= topLeftX && entity.xy.y >= topLeftY && entity.xy.x < topLeftX + screenWidth && entity.xy.y < topLeftY + screenHeight) {\n                display.draw(entity.xy.x - topLeftX, entity.xy.y - topLeftY, entity.chr, entity.foreground, entity.background);\n                // Get the messages in the player's queue and render them\n                var messages = _this.player.messages;\n                for (var _i = 0; _i < messages.length; _i++) {\n                    // Draw each message, adding the number of lines\n                    display.drawText(0, _i, messages[_i]);\n                }\n                // Render player HP\n                var stats = vsprintf('HP: %d/%d ', [_this.player.hp, _this.player.maxHp]);\n                display.drawText(0, __WEBPACK_IMPORTED_MODULE_3__const__[\"a\" /* DisplayOptions */].height - 1, stats);\n            }\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        if (inputType === 'keydown') {\n            // If enter is pressed, go to the win screen\n            // If escape is pressed, go to lose screen\n            if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RETURN) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.winScreen);\n            } else if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_ESCAPE) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.loseScreen);\n            } else {\n                // Movement\n                if (inputData.keyCode in _this.keys) {\n                    var direction = _this.keys[inputData.keyCode];\n                    if (direction === -1) {\n                        // Wait 1 turn\n                        // Unlock the engine\n                        _this.map.engine.unlock();\n                        return true;\n                    }\n\n                    var dir = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.DIRS[8][direction];\n                    _this.move(new __WEBPACK_IMPORTED_MODULE_4__xy__[\"a\" /* default */](dir[0], dir[1]));\n\n                    // Unlock the engine\n                    _this.map.engine.unlock();\n                }\n            }\n        }\n    }\n};\n\n// Define our winning screen\nScreen.winScreen = {\n    enter: function enter() {\n        console.log(\"Entered win screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited win screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        for (var i = 0; i < 22; i++) {\n            // Generate random background colors\n            var r = Math.round(Math.random() * 255);\n            var g = Math.round(Math.random() * 255);\n            var b = Math.round(Math.random() * 255);\n            var background = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Color.toRGB([r, g, b]);\n            display.drawText(2, i + 1, \"%b{\" + background + \"}You win!\");\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // Nothing to do here\n    }\n};\n\n// Define our losing screen\nScreen.loseScreen = {\n    enter: function enter() {\n        console.log(\"Entered lose screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited lose screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        for (var i = 0; i < 22; i++) {\n            display.drawText(2, i + 1, \"%b{red}You lose! :(\");\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // Nothing to do here\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Screen);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__glyph__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__const__ = __webpack_require__(1);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar Tile = function (_Glyph) {\n    _inherits(Tile, _Glyph);\n\n    function Tile(type) {\n        _classCallCheck(this, Tile);\n\n        var properties = __WEBPACK_IMPORTED_MODULE_1__const__[\"c\" /* Tiles */][type];\n\n        var _this = _possibleConstructorReturn(this, (Tile.__proto__ || Object.getPrototypeOf(Tile)).call(this, properties));\n\n        _this.type = type;\n        _this.isWalkable = properties[\"isWalkable\"] || false;\n        _this.isDiggable = properties[\"isDiggable\"] || false;\n        return _this;\n    }\n\n    return Tile;\n}(__WEBPACK_IMPORTED_MODULE_0__glyph__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Tile);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar asap = __webpack_require__(15);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (Array.isArray(parse_tree[i])) {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                        break\n                    case 'e':\n                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(match[8])) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n                parse_tree.push(match)\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (true) {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n        }\n    }\n    /* eslint-enable quote-props */\n}()\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  __webpack_require__(23).enable();\r\n  window.Promise = __webpack_require__(22);\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\n__webpack_require__(24);\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = __webpack_require__(20);\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(4);\n\n\n\nif (!__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.isSupported()) {\n    alert(\"The rot.js library isn't supported by your browser.\");\n} else {\n    // Initialize the game\n    __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].init();\n}\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__xy__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__entity__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__entities__ = __webpack_require__(2);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\nvar Map = function () {\n    function Map(tiles, player) {\n        _classCallCheck(this, Map);\n\n        _initialiseProps.call(this);\n\n        this.tiles = tiles;\n        // cache the width and height based\n        // on the length of the dimensions of\n        // the tiles array\n        this.width = tiles.length;\n        this.height = tiles[0].length;\n        // create a list which will hold the entities\n        this.entities = [];\n        // create the engine and scheduler\n        this.scheduler = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Scheduler.Simple();\n        this.engine = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Engine(this.scheduler);\n        // add the player\n        this.addEntityAtRandomPosition(player);\n        // add random fungi\n        for (var i = 0; i < 50; i++) {\n            this.addEntityAtRandomPosition(new __WEBPACK_IMPORTED_MODULE_3__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__entities__[\"b\" /* FungusTemplate */]));\n        }\n        // add enemy\n        this.addEntityAtRandomPosition(new __WEBPACK_IMPORTED_MODULE_3__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__entities__[\"c\" /* EnemyTemplate */]));\n    }\n\n    _createClass(Map, [{\n        key: 'getTile',\n        value: function getTile(xy) {\n            // Make sure we are inside the bounds. If we aren't, return\n            // null tile.\n            if (!this.isInBounds(xy)) {\n                return new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"null\");\n            } else {\n                return this.tiles[xy.x][xy.y] || new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"null\");\n            }\n        }\n    }, {\n        key: 'dig',\n        value: function dig(xy) {\n            if (this.getTile(xy).isDiggable) {\n                this.tiles[xy.x][xy.y] = new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"floor\");\n            }\n        }\n    }, {\n        key: 'getRandomFloorTile',\n        value: function getRandomFloorTile() {\n            var x = void 0,\n                y = void 0;\n            do {\n                x = Math.floor(__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.RNG.getUniform() * this.width);\n                y = Math.floor(__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.RNG.getUniform() * this.width);\n            } while (!this.isEmptyFloor(new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](x, y)));\n            return new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](x, y);\n        }\n    }, {\n        key: 'isInBounds',\n        value: function isInBounds(xy) {\n            return xy.x > 0 && xy.x < this.width && xy.y > 0 && xy.y < this.height;\n        }\n    }, {\n        key: 'getEntityAt',\n        value: function getEntityAt(xy) {\n            for (var i = 0; i < this.entities.length; i++) {\n                if (this.entities[i].xy.is(xy)) {\n                    return this.entities[i];\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'addEntity',\n        value: function addEntity(entity) {\n            // Make sure the entity's position is within bounds\n            if (!this.isInBounds(entity.xy)) {\n                throw new Error('Adding entity out of bounds.');\n            }\n            // Update the entity's map\n            entity.map = this;\n            // Add the entity to the list of entities\n            this.entities.push(entity);\n            // Check if this entity is an actor, and if so add\n            // them to the scheduler\n            if (entity.hasMixin('Actor')) {\n                this.scheduler.add(entity, true);\n            }\n        }\n    }, {\n        key: 'addEntityAtRandomPosition',\n        value: function addEntityAtRandomPosition(entity) {\n            entity.xy = this.getRandomFloorTile();\n            this.addEntity(entity);\n        }\n    }, {\n        key: 'isEmptyFloor',\n        value: function isEmptyFloor(xy) {\n            // Check if the tile is floor and also has no entity\n            return this.getTile(xy).type === \"floor\" && !this.getEntityAt(xy);\n        }\n    }, {\n        key: 'removeEntity',\n        value: function removeEntity(entity) {\n            // Find the entity in the list of entities if it is present\n            for (var i = 0; i < this.entities.length; i++) {\n                if (this.entities[i] === entity) {\n                    this.entities.splice(i, 1);\n                    break;\n                }\n            }\n            // If the entity is an actor, remove them from the scheduler\n            if (entity.hasMixin('Actor')) {\n                this.scheduler.remove(entity);\n            }\n        }\n    }]);\n\n    return Map;\n}();\n\nvar _initialiseProps = function _initialiseProps() {\n    this.getEntitiesWithinRadius = function (centerXY, radius) {\n        var results = [];\n        // Determine our bounds\n        var leftX = centerXY.x - radius;\n        var rightX = centerXY.x + radius;\n        var topY = centerXY.y - radius;\n        var bottomY = centerXY.y + radius;\n        // Iterate through our entities, adding any which are within the bounds\n        for (var i = 0; i < this.entities.length; i++) {\n            if (this.entities[i].xy.x >= leftX && this.entities[i].xy.x <= rightX && this.entities[i].xy.y >= topY && this.entities[i].xy.y <= bottomY) {\n                results.push(this.entities[i]);\n            }\n        }\n        return results;\n    };\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Map);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GenerateMap;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__map__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__const__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tile__ = __webpack_require__(9);\n\n\n\n\n\nfunction GenerateMap(player) {\n    var map = [];\n    for (var x = 0; x < __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].width; x++) {\n        // Create the nested array for the y values\n        map.push([]);\n        // Add all the tiles\n        for (var y = 0; y < __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].height; y++) {\n            map[x].push(new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"null\"));\n        }\n    }\n    // Setup the map generator\n    var generator = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Map.Digger(__WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].width, __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].height);\n    generator.create(function (x, y, value) {\n        if (value) {\n            map[x][y] = new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"wall\");\n        } else {\n            map[x][y] = new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"floor\");\n        }\n    });\n    // Create our map from the tiles\n    return new __WEBPACK_IMPORTED_MODULE_1__map__[\"a\" /* default */](map, player);\n}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = sendMessage;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = sendMessageNearby;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_js__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sprintf_js__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sprintf_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sprintf_js__);\n\n\n\nvar vsprintf = __WEBPACK_IMPORTED_MODULE_1_sprintf_js___default.a.vsprintf;\nvar sprintf = __WEBPACK_IMPORTED_MODULE_1_sprintf_js___default.a.sprintf;\n\nfunction sendMessage(recipient, message, args) {\n    // Make sure the recipient can receive the message\n    // before doing any work.\n    if (recipient.hasMixin(__WEBPACK_IMPORTED_MODULE_0__mixins_js__[\"a\" /* default */].MessageRecipient)) {\n        // If args were passed, then we format the message, else\n        // no formatting is necessary\n        if (args) {\n            message = vsprintf(message, args);\n        }\n        recipient.receiveMessage(message);\n    }\n}\n\nfunction sendMessageNearby(map, centerXY, message, args) {\n    // Get the nearby entities\n    var entities = map.getEntitiesWithinRadius(centerXY, 5);\n    // Iterate through nearby entities, sending the message if\n    // they can receive it.\n    for (var i = 0; i < entities.length; i++) {\n        sendMessage(entities[i], message, args);\n    }\n}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar require;var require;(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dice = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"dice.js\",\n  \"version\": \"0.9.3\",\n  \"description\": \"A parser and evaluator for a useful rpg dice syntax.\",\n  \"main\": \"build/dice.js\",\n  \"directories\": {\n    \"test\": \"tests\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"browserify\": \"~14.1.0\",\n    \"jasmine-core\": \"^2.5.2\",\n    \"jasmine-node\": \"~1.14.5\",\n    \"karma\": \"~1.5.0\",\n    \"karma-chrome-launcher\": \"~2.0\",\n    \"karma-firefox-launcher\": \"~1.0.1\",\n    \"karma-jasmine\": \"~1.1\",\n    \"karma-phantomjs-launcher\": \"~1.0.4\",\n    \"pegjs\": \"~0.10.0\"\n  },\n  \"scripts\": {\n    \"test\": \"make test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/lordnull/dice.js.git\"\n  },\n  \"keywords\": [\n    \"rpg\",\n    \"dice\",\n    \"parser\",\n    \"roll\",\n    \"peg\"\n  ],\n  \"author\": \"Micah Warren (Lord Null)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/lordnull/dice.js/issues\"\n  },\n  \"homepage\": \"https://github.com/lordnull/dice.js\"\n}\n\n},{}],2:[function(require,module,exports){\nvar dice = {\n\tparse: require('./parser').parse,\n\teval: require('./evaluate').eval,\n\tops: require('./evaluate').ops,\n\tversion: require('../package').version\n};\n\nfunction roll(str, scope){\n\tvar parsed = dice.parse(str);\n\tvar evaled = dice.eval(parsed, scope);\n\treturn evaled;\n};\n\ndice.roll = roll;\n\ndice.statistics = function(str, scope, samples){\n\tif(typeof(scope) == \"number\"){\n\t\tsamples = scope;\n\t\tscope = {};\n\t}\n\tscope = scope || {};\n\tsamples = samples || 1000;\n\tvar resultSet = [];\n\tvar i;\n\tfor(i = 0; i < samples; i++){\n\t\tresultSet.push(roll(str, scope));\n\t}\n\tvar mean = resultSet.reduce(function(n, acc){ return n + acc; }, 0) / samples;\n\tvar min = resultSet.reduce(function(n, acc){ return n < acc ? n : acc; }, resultSet[0]);\n\tvar max = resultSet.reduce(function(n, acc){ return n > acc ? n : acc; }, resultSet[0]);\n\n\tvar parsed = dice.parse(str);\n\n\tvar minMaxPossible = determine_min_max_possible(parsed, scope);\n\n\treturn {\n\t\t'results': resultSet,\n\t\t'mean': mean,\n\t\t'min': parseInt(min.toFixed()),\n\t\t'max': parseInt(max.toFixed()),\n\t\t'min_possible': minMaxPossible[0],\n\t\t'max_possible': minMaxPossible[1]\n\t};\n};\n\nfunction determine_min_max_possible(opObject, scope){\n\tif(opObject.op == 'static'){\n\t\treturn [opObject.value, opObject.value];\n\t}\n\tif(opObject.op == 'lookup'){\n\t\tvar lookup = dice.ops.lookup.call(opObject, scope);\n\t\treturn [lookup(scope), lookup(scope)];\n\t}\n\tif(opObject.op == 'floor'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.floor(minmax[0]), Math.floor(minmax[1])];\n\t}\n\tif(opObject.op == 'ceil'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.ceil(minmax[0]), Math.ceil(minmax[1])];\n\t}\n\tif(opObject.op == 'round'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.round(minmax[0]), Math.round(minmax[1])];\n\t}\n\tif(opObject.op == 'd'){\n\t\tvar multipleMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar randPartMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = randPartMinMax[0] * multipleMinMax[0];\n\t\tvar max = randPartMinMax[1] * multipleMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'w'){\n\t\tvar multipleMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar randPartMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = randPartMinMax[0] * multipleMinMax[0];\n\t\tvar max = randPartMinMax[1] * multipleMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'random'){\n\t\tvar minMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar maxMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\treturn [minMinMax[0], maxMinMax[1]];\n\t}\n\tif(opObject.op == '+'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] + rightMinMax[0];\n\t\tvar max = leftMinMax[1] + rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '-'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] - rightMinMax[0];\n\t\tvar max = leftMinMax[1] - rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '*'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] * rightMinMax[0];\n\t\tvar max = leftMinMax[1] * rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '/'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] / rightMinMax[1];\n\t\tvar max = leftMinMax[1] / rightMinMax[0];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'paren_express'){\n\t\treturn determine_min_max_possible(opObject.args[0], scope);\n\t}\n}\n\nfunction stringify_expression(evaled_op){\n\tvar sub = stringify(evaled_op.expression);\n\tvar prefix = evaled_op.op[0];\n\tif(prefix === 'p'){\n\t\tprefix = '';\n\t}\n\t\n\treturn prefix + \"( \" + sub + \" )\";\n};\n\nfunction stringify_op(evaled_op){\n\tvar rs = stringify(evaled_op.rightSide);\n\tvar ls = stringify(evaled_op.leftSide);\n\treturn rs + ' ' + evaled_op.op + ' ' + ls;\n};\n\nfunction stringify_rolls(evaled_roll){\n\tvar minStr = evaled_roll.min > 1 ? evaled_roll.min + '..' : '';\n\tvar preamble = evaled_roll.x + evaled_roll.mode + minStr + evaled_roll.max + ':[';\n\treturn preamble + evaled_roll.rolls.join(', ') + ']';\n};\n\nfunction stringify(evaled){\n\tif(evaled.expression){\n\t\treturn stringify_expression(evaled);\n\t}\n\n\tif(evaled.op){\n\t\treturn stringify_op(evaled);\n\t}\n\n\tif(evaled.rolls){\n\t\treturn stringify_rolls(evaled);\n\t}\n\n\treturn evaled.toString();\n};\n\ndice.stringify = stringify;\n\nvar k;\nfor(k in dice){\n    exports[k] = dice[k];\n}\n\n\n},{\"../package\":1,\"./evaluate\":3,\"./parser\":4}],3:[function(require,module,exports){\n\nfunction makeSeq(endIndex){\n\tvar seq = [];\n\tseq[endIndex] = true;\n\tfor(var i = 0; i < seq.length; i++){\n\t\tseq[i] = true;\n\t}\n\treturn seq;\n};\n\nvar ops = {\n\n\t'static': function(){\n\t\tvar outValue = this.value;\n\t\treturn function(){\n\t\t\treturn outValue;\n\t\t};\n\t},\n\n\t'lookup': function(){\n\t\tvar variableName = this.value;\n\t\treturn function(scope){\n\t\t\tvar undef;\n\t\t\tvar out = scope[variableName];\n\t\t\tif(out != undef){\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\tvar split = variableName.split('.');\n\t\t\tif(variableName == split){\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\treduceRes = split.reduce(function(acc, elem){\n\t\t\t\tif(acc == undef){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn acc[elem];\n\t\t\t}, scope);\n\t\t\treturn reduceRes;\n\t\t}\n\t},\n\n\t'floor': function(value){\n\t\treturn function(scope){\n\t\t\tvar floorable = value(scope);\n\t\t\tvar tots = new Number(Math.floor(floorable));\n\t\t\ttots.op = 'floor';\n\t\t\ttots.expression = floorable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'ceil': function(value){\n\t\treturn function(scope){\n\t\t\tvar ceilable = value(scope);\n\t\t\tvar tots = new Number(Math.ceil(ceilable));\n\t\t\ttots.op = 'ceil';\n\t\t\ttots.expression = ceilable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'round': function(value){\n\t\treturn function(scope){\n\t\t\tvar roundable = value(scope);\n\t\t\tvar tots = new Number(Math.round(roundable));\n\t\t\ttots.op = 'round';\n\t\t\ttots.expression = roundable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'd': function(numRolls, minMax){\n\t\treturn function(scope){\n\t\t\tvar x = numRolls(scope);\n\t\t\tvar seq = makeSeq(x - 1);\n\t\t\tvar outMin, outMax;\n\t\t\tvar rolled = seq.map(function(){\n\t\t\t\tvar rolledRet = minMax(scope);\n\t\t\t\toutMin = rolledRet.min;\n\t\t\t\toutMax = rolledRet.max;\n\t\t\t\treturn rolledRet;\n\t\t\t});\n\t\t\tvar out = rolled.reduce(function(sum, val){\n\t\t\t\treturn sum + val;\n\t\t\t}, 0);\n\t\t\tout = new Number(out);\n\t\t\tout.rolls = rolled;\n\t\t\tout.min = outMin;\n\t\t\tout.max = outMax;\n\t\t\tout.x = x;\n\t\t\tout.mode = 'd';\n\t\t\treturn out;\n\t\t};\n\t},\n\n\t'w': function(numRolls, minMax){\n\t\treturn function(scope){\n\t\t\tvar x = numRolls(scope);\n\t\t\tvar seq = makeSeq(x - 1);\n\t\t\tvar outMin, outMax;\n\t\t\tvar rolled = seq.map(function(){\n\t\t\t\tvar lastRolled = minMax(scope);\n\t\t\t\tvar wildrolled = 0;\n\t\t\t\toutMin = minMax.min;\n\t\t\t\toutMax = minMax.max;\n\t\t\t\tif(minMax.min === minMax.max){\n\t\t\t\t\treturn lastRolled;\n\t\t\t\t}\n\t\t\t\twhile(lastRolled === minMax.max){\n\t\t\t\t\twildrolled += lastRolled;\n\t\t\t\t\tlastRolled = mimMax(scope);\n\t\t\t\t}\n\t\t\t\treturn wildrolled;\n\t\t\t});\n\t\t\tvar out = rolled.reduce(function(sum, val){\n\t\t\t\treturn sum + val;\n\t\t\t}, 0);\n\t\t\tout = new Number(out);\n\t\t\tout.rolls = rolled;\n\t\t\tout.min = outMin;\n\t\t\tout.max = outMax;\n\t\t\tout.x = x;\n\t\t\tout.mode = 'w';\n\t\t\treturn out;\n\t\t};\n\t},\n\n\t'random': function(minFun, maxFun){\n\t\treturn function(scope){\n\t\t\tvar rawRandom = Math.random();\n\t\t\tvar max = maxFun(scope);\n\t\t\tvar min = minFun(scope);\n\t\t\tvar diff = max - min;\n\t\t\tvar rawRandom = diff * rawRandom;\n\t\t\tvar rndNumber = Math.round(rawRandom + min);\n\t\t\trndNumber = new Number(rndNumber);\n\t\t\trndNumber.min = min;\n\t\t\trndNumber.max = max;\n\t\t\treturn rndNumber;\n\t\t};\n\t},\n\n\t'+': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar sum = rightSide + leftSide;\n\t\t\tsum = new Number(sum);\n\t\t\tsum.op = '+';\n\t\t\tsum.rightSide = rightSide;\n\t\t\tsum.leftSide = leftSide;\n\t\t\treturn sum;\n\t\t};\n\t},\n\n\t'-': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar sum = rightSide - leftSide;\n\t\t\tsum = new Number(sum);\n\t\t\tsum.op = '-';\n\t\t\tsum.rightSide = rightSide;\n\t\t\tsum.leftSide = leftSide;\n\t\t\treturn sum;\n\t\t};\n\t},\n\n\t'*': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar tots = rightSide * leftSide;\n\t\t\ttots = new Number(tots);\n\t\t\ttots.op = '*';\n\t\t\ttots.rightSide = rightSide;\n\t\t\ttots.leftSide = leftSide;\n\t\t\treturn tots;\n\t\t};\n\t},\n\n\t'/': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar tots = rightSide / leftSide;\n\t\t\ttots = new Number(tots);\n\t\t\ttots.op = '/';\n\t\t\ttots.rightSide = rightSide;\n\t\t\ttots.leftSide = leftSide;\n\t\t\treturn tots;\n\t\t};\n\t},\n\n\t'paren_express': function(op){\n\t\treturn function(scope){\n\t\t\tvar tots = op(scope);\n\t\t\touttots = new Number(tots);\n\t\t\touttots.op = 'paren_express';\n\t\t\touttots.expression = tots;\n\t\t\treturn outtots;\n\t\t};\n\t}\n\n};\n\nfunction resolve_ops(args){\n\targs = args || [];\n\treturn args.map(resolve_op);\n};\n\nfunction resolve_op(opObj){\n\tvar subArgs = resolve_ops(opObj.args);\n\treturn ops[opObj.op].apply(opObj, subArgs);\n};\n\n\nexports.eval = function(parsed, scope){\n\tscope = scope || {};\n\tvar ops = resolve_op(parsed)\n\treturn ops(scope);\n\n\t/*var acc = {sum: 0, mode: \"+\", rolls: [], 'scope':scope}\n\tvar reduced = parsed.reduce(reduceThemBones, acc);\n\treturn {sum: reduced.sum, rolls: reduced.rolls};*/\n}\n\nexports.ops = ops;\n\n\n},{}],4:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = function(v1, op, v2) { return {'op':op, args: [v1, v2] }; },\n      peg$c1 = function(out) { return out; },\n      peg$c2 = \"(\",\n      peg$c3 = peg$literalExpectation(\"(\", false),\n      peg$c4 = \")\",\n      peg$c5 = peg$literalExpectation(\")\", false),\n      peg$c6 = function(rolls) { return {'op':'paren_express', args: [rolls]} },\n      peg$c7 = \"*\",\n      peg$c8 = peg$literalExpectation(\"*\", false),\n      peg$c9 = function() { return '*'; },\n      peg$c10 = \"/\",\n      peg$c11 = peg$literalExpectation(\"/\", false),\n      peg$c12 = function() { return '/'; },\n      peg$c13 = function(v1, op, v2) { return {'op':op, args:[v1, v2] }; },\n      peg$c14 = function(d) { return d; },\n      peg$c15 = function(paren) { return paren; },\n      peg$c16 = function(v1, op, v2) { return {'op':op, args:[v1, v2]}; },\n      peg$c17 = function(op) { return op; },\n      peg$c18 = \"+\",\n      peg$c19 = peg$literalExpectation(\"+\", false),\n      peg$c20 = function() { return \"+\"; },\n      peg$c21 = \"-\",\n      peg$c22 = peg$literalExpectation(\"-\", false),\n      peg$c23 = function() { return \"-\"; },\n      peg$c24 = function(x, mode, mm) { return {'op':mode, 'args':[x, mm]} },\n      peg$c25 = function(mode, mm) { return {'op':mode, 'args':[{'op':'static', 'value':1}, mm]}; },\n      peg$c26 = function(mm) { return { 'op':'d', 'args':[ {'op':'static', 'value':1}, mm]}; },\n      peg$c27 = function(x) { return x; },\n      peg$c28 = \"d\",\n      peg$c29 = peg$literalExpectation(\"d\", false),\n      peg$c30 = \"w\",\n      peg$c31 = peg$literalExpectation(\"w\", false),\n      peg$c32 = function(mm) { return mm; },\n      peg$c33 = function(max) { return {'op':'random', 'args':[{'op':'static', 'args':[], 'value':1}, max]}; },\n      peg$c34 = \"..\",\n      peg$c35 = peg$literalExpectation(\"..\", false),\n      peg$c36 = function(min, max) { return {'op':'random', 'args':[min, max]}; },\n      peg$c37 = /^[ ]/,\n      peg$c38 = peg$classExpectation([\" \"], false, false),\n      peg$c39 = function(i) {\n      \t\treturn {'op': 'static', value: i};\n      \t},\n      peg$c40 = function(l) {\n      \t\treturn l;\n      \t},\n      peg$c41 = function(f, v) {\n      \t\treturn {'op':f, args:[v]};\n      \t},\n      peg$c42 = function(f, ex) {\n          return {'op':f, args:ex.args};\n      \t},\n      peg$c43 = \"f\",\n      peg$c44 = peg$literalExpectation(\"f\", false),\n      peg$c45 = function() { return 'floor'; },\n      peg$c46 = \"r\",\n      peg$c47 = peg$literalExpectation(\"r\", false),\n      peg$c48 = function() { return 'round'; },\n      peg$c49 = \"c\",\n      peg$c50 = peg$literalExpectation(\"c\", false),\n      peg$c51 = function() { return 'ceil'; },\n      peg$c52 = function(v) { return {'op':'lookup', 'value':v}; },\n      peg$c53 = \"[\",\n      peg$c54 = peg$literalExpectation(\"[\", false),\n      peg$c55 = /^[^[\\]]/,\n      peg$c56 = peg$classExpectation([\"[\", \"]\"], true, false),\n      peg$c57 = \"]\",\n      peg$c58 = peg$literalExpectation(\"]\", false),\n      peg$c59 = function(varname) { return varname.join(\"\"); },\n      peg$c60 = peg$otherExpectation(\"integer\"),\n      peg$c61 = /^[0-9]/,\n      peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c63 = function(digits) { return parseInt(digits.join(\"\"), 10); },\n      peg$c64 = function(digits) { return parseInt(digits.join(\"\"), 10) * -1; },\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsedicerolls();\n\n    return s0;\n  }\n\n  function peg$parsedicerolls() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiplicationSeq();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseadditionOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseadditionSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseadditionSeq();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseparenExpress();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseparenExpress() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c2;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsews();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedicerolls();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsews();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c4;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c6(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicationOp() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsews();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s2 = peg$c7;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsews();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c10;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsews();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c12();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicationSeq() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsediceroll();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemultiplicationOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemultiplicationSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseparenExpress();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemultiplicationOp();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemultiplicationSeq();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsediceroll();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c14(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseparenExpress();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c15(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditionSeq() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiplicationSeq();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseadditionOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseadditionSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsemultiplicationSeq();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseparenExpress();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c17(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditionOp() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsews();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s2 = peg$c18;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsews();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c21;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsews();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c23();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsediceroll() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseintval();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parserollmode();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemaybe_minmax();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parserollmode();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemaybe_minmax();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseminmax();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c26(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseintval();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c27(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parserollmode() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 100) {\n      s0 = peg$c28;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 119) {\n        s0 = peg$c30;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemaybe_minmax() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseminmax();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseintval();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseminmax() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseintval();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c34) {\n        s2 = peg$c34;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseintval();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c37.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c38); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c37.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintval() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseinteger();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c39(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parselookup();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c40(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsemathit();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parselookup();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c41(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemathit();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseparenExpress();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c42(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemathit() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 102) {\n      s1 = peg$c43;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c45();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 114) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 99) {\n          s1 = peg$c49;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c51();\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parselookup() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsevariable();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c52(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsevariable() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c53;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$c55.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c56); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c55.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c57;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c58); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c59(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseinteger() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c61.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c63(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c62); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c64(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c60); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n},{}]},{},[2])(2)\n});\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(10);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(10);\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(13);\nmodule.exports = __webpack_require__(14);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// static/js/main.89009b7f.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dung/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e2e24a5fde3fae499f35","/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rot-js/lib/rot.js\n// module id = 0\n// module chunks = 0","const DisplayOptions = {\r\n    width: 80,\r\n    height: 25\r\n}\r\n\r\nconst MapOptions = {\r\n    width: 160,\r\n    height: 50\r\n}\r\n\r\nconst Tiles = {\r\n    \"null\": {\r\n    },\r\n    floor: {\r\n        chr: \".\",\r\n        foreground: \"#444\",\r\n        background: \"#222\",\r\n        isWalkable: true\r\n    },\r\n    wall: {\r\n        chr: \"#\",\r\n        foreground: \"#777\",\r\n        background: \"#2e2e2e\",\r\n        isDiggable: true\r\n    }\r\n}\r\n\r\nexport {DisplayOptions, MapOptions, Tiles};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","import Mixins from './mixins'\r\n\r\n// Player template\r\nexport const PlayerTemplate = {\r\n    chr: '@',\r\n    foreground: 'white',\r\n    background: 'black',\r\n    maxHp: 40,\r\n    attackValue: \"2d6\",\r\n    mixins: [Mixins.Moveable, Mixins.PlayerActor,\r\n             Mixins.Attacker, Mixins.Destructible,\r\n             Mixins.MessageRecipient]\r\n}\r\n\r\n// Fungus template\r\nexport const FungusTemplate = {\r\n    chr: 'F',\r\n    foreground: 'green',\r\n    name: \"fungus\",\r\n    maxHp: 10,\r\n    mixins: [Mixins.FungusActor, Mixins.Destructible]\r\n}\r\n\r\nexport const EnemyTemplate = {\r\n    chr: '☹',\r\n    foreground: 'red',\r\n    name: \"most evil creature in the world\",\r\n    maxHp: 20,\r\n    attackValue: \"3d3\",\r\n    mixins: [Mixins.Moveable, Mixins.EnemyActor,\r\n             Mixins.Attacker, Mixins.Destructible]\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entities.js","import Glyph from './glyph'\r\n\r\nexport default class Entity extends Glyph {\r\n    constructor(properties = {}) {\r\n        super(properties);\r\n        this.name = properties[\"name\"] || \"\";\r\n        this.xy = properties[\"xy\"] || 0;\r\n        this.map = null;\r\n        // Create an object which will keep track what mixins we have\r\n        // attached to this entity based on the name property\r\n        this.attachedMixins = {};\r\n        // Create a similar object for groups\r\n        this.attachedMixinGroups = {};\r\n        // Setup the object's mixins\r\n        const mixins = properties['mixins'] || [];\r\n        for (let i = 0; i < mixins.length; i++) {\r\n            // Copy over all properties from each mixin as long\r\n            // as it's not the name or the init property. We\r\n            // also make sure not to override a property that\r\n            // already exists on the entity.\r\n            for (const key in mixins[i]) {\r\n                if (key !== 'init' && key !== 'name' && !this.hasOwnProperty(key)) {\r\n                    this[key] = mixins[i][key];\r\n                }\r\n            }\r\n            // Add the name of this mixin to our attached mixins\r\n            this.attachedMixins[mixins[i].name] = true;\r\n            // If a group name is present, add it\r\n            if (mixins[i].groupName) {\r\n                this.attachedMixinGroups[mixins[i].groupName] = true;\r\n            }\r\n            // Finally call the init function if there is one\r\n            if (mixins[i].init) {\r\n                mixins[i].init.call(this, properties);\r\n            }\r\n        }\r\n    }\r\n    hasMixin(obj) {\r\n        // Allow passing the mixin itself or the name / group name as a string\r\n        if (typeof obj === 'object') {\r\n            return this.attachedMixins[obj.name];\r\n        } else {\r\n            return this.attachedMixins[obj] || this.attachedMixinGroups[obj];\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entity.js","import ROT from 'rot-js'\r\nimport Screen from './screens'\r\nimport {DisplayOptions} from './const'\r\n\r\nclass Game {\r\n    constructor() {\r\n        this.currentScreen = null;\r\n    }\r\n    init() {\r\n        // Initialize display\r\n        this.display = new ROT.Display(DisplayOptions);\r\n        // Append display to the document (HTML file)\r\n        // This creates an <canvas> in the document\r\n        document.body.appendChild(this.display.getContainer());\r\n        // Helper function\r\n        const bindEventToScreen = event => {\r\n            window.addEventListener(event, (e) => {\r\n                // When an event is received, send it to the\r\n                // screen if there is one\r\n                if (this.currentScreen !== null) {\r\n                    // Send the event type and data to the screen\r\n                    this.currentScreen.handleInput(event, e);\r\n                }\r\n            });\r\n        }\r\n        // Bind keyboard input events\r\n        bindEventToScreen('keydown');\r\n        // bindEventToScreen('keyup');\r\n        // bindEventToScreen('keypress');\r\n        this.switchScreen(Screen.startScreen);\r\n    }\r\n    switchScreen(screen) {\r\n        // If we had a screen before, notify it that we exited\r\n        if (this.currentScreen !== null) {\r\n            this.currentScreen.exit();\r\n        }\r\n        // Clear the display\r\n        this.display.clear();\r\n        // Update our current screen, notify it we entered\r\n        // and then render it\r\n        this.currentScreen = screen;\r\n        if (this.currentScreen) {\r\n            this.currentScreen.enter();\r\n            this.refresh();\r\n        }\r\n    }\r\n    refresh() {\r\n        // Clear the screen\r\n        this.display.clear();\r\n        // Render the screen\r\n        this.currentScreen.render(this.display);\r\n    }\r\n}\r\n\r\nconst game = new Game();\r\nexport default game;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","export default class XY {\r\n\tconstructor(x = 0, y = 0) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\ttoString() {\r\n\t\treturn this.x + \",\" + this.y;\r\n\t}\r\n\tis(xy) {\r\n\t\treturn (this.x === xy.x && this.y === xy.y);\r\n\t}\r\n\tdist8(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\r\n\t}\r\n\tdist4(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.abs(dx) + Math.abs(dy);\r\n\t}\r\n\tdist(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.sqrt(dx*dx+dy*dy);\r\n\t}\r\n\tplus(xy) {\r\n\t\treturn new XY(this.x+xy.x, this.y+xy.y);\r\n\t}\r\n\tminus(xy) {\r\n\t\treturn new XY(this.x-xy.x, this.y-xy.y);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/xy.js","// This class is needed to make coloured characters with coloured background.\r\nexport default class Glyph {\r\n    constructor(properties = {}) {\r\n        this.chr = properties[\"chr\"] || \"\";\r\n        this.foreground = properties[\"foreground\"] || \"#ccc\";\r\n        this.background = properties[\"background\"] || null;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/glyph.js","import ROT from 'rot-js'\r\nimport XY from './xy'\r\nimport game from './game'\r\nimport Entity from './entity'\r\nimport {FungusTemplate} from './entities'\r\nimport Screen from './screens'\r\nimport dice from 'dice.js'\r\nimport {sendMessage, sendMessageNearby} from './msg'\r\n\r\n// Create our Mixins namespace\r\nconst Mixins = {};\r\n\r\n// Define our Moveable mixin\r\nMixins.Moveable = {\r\n    name: 'Moveable',\r\n    tryMove: function(xy, map) {\r\n        const tile = map.getTile(xy);\r\n        // If an entity was present at the tile\r\n        const target = map.getEntityAt(xy);\r\n        if (target) {\r\n            // If we are an attacker, try to attack\r\n            // the target\r\n            if (this.hasMixin('Attacker')) {\r\n                this.attack(target);\r\n                return true;\r\n            } else {\r\n                // If not nothing we can do, but we can't\r\n                // move to the tile\r\n                return false;\r\n            }\r\n        }\r\n        // Check if we can walk on the tile\r\n        // and if so simply walk onto it\r\n        if (tile.isWalkable) {\r\n            // Update the entity's position\r\n            this.xy = xy;\r\n            return true;\r\n        // Check if the tile is diggable, and\r\n        // if so try to dig it\r\n        } else if (tile.isDiggable) {\r\n            map.dig(xy);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\nMixins.Destructible = {\r\n    name: 'Destructible',\r\n    init: function(template = {\"maxHp\": 10, \"defenseValue\": 0}) {\r\n        this.maxHp = template[\"maxHp\"] || 10;\r\n        // We allow taking in health from the template incase we want\r\n        // the entity to start with a different amount of HP than the\r\n        // max specified.\r\n        this.hp = template[\"hp\"] || this.maxHp;\r\n        this.defenseValue = template[\"defenseValue\"] || 0;\r\n    },\r\n    takeDamage: function(attacker, damage) {\r\n        this.hp -= damage;\r\n        // If have 0 or less HP, then remove ourselves from the map\r\n        if (this.hp <= 0) {\r\n            sendMessage(attacker, 'You kill the %s!', [this.name]);\r\n            sendMessage(this, 'You die!');\r\n            if (this.hasMixin(\"PlayerActor\")) { // If ourself is player\r\n                this.map.engine.lock();\r\n                // game.switchScreen(Screen.loseScreen); // Show Game Over screen\r\n            }\r\n            this.map.removeEntity(this);\r\n        }\r\n    }\r\n}\r\n\r\nMixins.SimpleAttacker = {\r\n    name: 'SimpleAttacker',\r\n    groupName: 'Attacker',\r\n    attack: function(target) {\r\n        // Only remove the entity if they were attackable\r\n        if (target.hasMixin('Destructible')) {\r\n            target.takeDamage(this, 1);\r\n        }\r\n    }\r\n}\r\n\r\nMixins.Attacker = {\r\n    name: 'Attacker',\r\n    groupName: 'Attacker',\r\n    init: function(template = {\"attackValue\": \"1d1\"}) {\r\n        this.attackValue = template[\"attackValue\"] || \"1d1\";\r\n    },\r\n    attack: function(target) {\r\n        // Only remove the entity if they were attackable\r\n        if (target.hasMixin('Destructible')) {\r\n            const damage = Math.max(0, dice.roll(this.attackValue) - target.defenseValue);\r\n            sendMessage(this, 'You strike the %s for %d damage!',\r\n                        [target.name, damage]);\r\n            sendMessage(target, 'The %s strikes you for %d damage!',\r\n                        [this.name, damage]);\r\n            target.takeDamage(this, damage);\r\n        }\r\n    }\r\n}\r\n\r\nMixins.PlayerActor = {\r\n    name: 'PlayerActor',\r\n    groupName: 'Actor',\r\n    act: function() {\r\n        // Re-render the screen\r\n        game.refresh();\r\n        // Lock the engine and wait asynchronously\r\n        // for the player to press a key.\r\n        this.map.engine.lock();\r\n        // Clear the message queue\r\n        this.clearMessages();\r\n    }\r\n}\r\n\r\nMixins.FungusActor = {\r\n    name: 'FungusActor',\r\n    groupName: 'Actor',\r\n    init: function() {\r\n        this.growthsRemaining = 5;\r\n        this.lifeTurns = 1000;\r\n    },\r\n    act: function() {\r\n        this.lifeTurns--;\r\n        if (this.lifeTurns === 100) {\r\n            this.foreground = \"goldenrod\";\r\n        }\r\n        if (this.lifeTurns <= 0) {\r\n            this.map.removeEntity(this); // fungi die if they are too old\r\n        }\r\n        if (this.growthsRemaining <= 0 || Math.random() > 0.02) {\r\n            return;\r\n        }\r\n        // Generate the coordinates of a random adjacent square by\r\n        // generating an offset between [-1, 0, 1] for both the x and\r\n        // y directions. To do this, we generate a number from 0-2 and then\r\n        // subtract 1.\r\n        const xyOffset = new XY(Math.floor(Math.random() * 3) - 1,\r\n                                Math.floor(Math.random() * 3) - 1);\r\n\r\n        // Make sure we aren't trying to spawn on the same tile as us\r\n        if (xyOffset.is(new XY())) {\r\n            return;\r\n        }\r\n\r\n        const xyLoc = this.xy.plus(xyOffset);\r\n\r\n        // Check if we can actually spawn at that location, and if so\r\n        // then we grow!\r\n        if (!this.map.isEmptyFloor(xyLoc)) {\r\n            return;\r\n        }\r\n\r\n        const entity = new Entity(FungusTemplate);\r\n        entity.xy = xyLoc;\r\n        this.map.addEntity(entity);\r\n        this.growthsRemaining--;\r\n        // Send a message nearby!\r\n        sendMessageNearby(this.map, entity.xy,\r\n                          'The fungus is spreading!');\r\n    }\r\n}\r\n\r\nMixins.EnemyActor = {\r\n    name: 'EnemyActor',\r\n    groupName: 'Actor',\r\n    act: function() {\r\n        if (!this.map.entities[0]) {\r\n            return;\r\n        }\r\n        let x = this.map.entities[0].xy.x;\r\n        let y = this.map.entities[0].xy.y;\r\n        let passableCallback = (x, y) => this.map.getTile(new XY(x, y)).isWalkable // this.map.isEmptyFloor(new XY(x, y));\r\n        const astar = new ROT.Path.AStar(x, y, passableCallback);\r\n\r\n        let path = [];\r\n        let pathCallback = (x, y) => path.push(new XY(x, y));\r\n        astar.compute(this.xy.x, this.xy.y, pathCallback);\r\n        x = path[1].x;\r\n        y = path[1].y;\r\n        this.tryMove(new XY(x, y), this.map);\r\n    }\r\n}\r\n\r\nMixins.Teleportable = {\r\n    name: 'Teleportable',\r\n    teleport: function(map) {\r\n        this.xy = map.getRandomFloorTile();\r\n        return true;\r\n    }\r\n}\r\n\r\nMixins.MessageRecipient = {\r\n    name: 'MessageRecipient',\r\n    init: function(template) {\r\n        this.messages = [];\r\n    },\r\n    receiveMessage: function(message) {\r\n        this.messages.push(message);\r\n    },\r\n    clearMessages: function() {\r\n        this.messages = [];\r\n    }\r\n}\r\n\r\nexport default Mixins;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins.js","//  How to make a screen\r\n//\r\n//  Screen.name {\r\n//      enter: () => {\r\n//          ...\r\n//      },\r\n//      exit: () => {\r\n//          ...\r\n//      },\r\n//      render: (display) => {\r\n//          ...\r\n//      },\r\n//      handleInput: (inputType, inputData) => {\r\n//          ...\r\n//      },\r\n//  }\r\n\r\nimport ROT from 'rot-js'\r\nimport game from './game'\r\nimport GenerateMap from './mapgen'\r\nimport {DisplayOptions} from './const'\r\nimport XY from './xy'\r\nimport Entity from './entity'\r\nimport {PlayerTemplate} from './entities'\r\nimport sprintfjs from 'sprintf-js'\r\n\r\nconst vsprintf = sprintfjs.vsprintf;\r\nconst sprintf = sprintfjs.sprintf;\r\n\r\nconst Screen = {};\r\n\r\n// Define our initial start screen\r\nScreen.startScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered start screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited start screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        display.drawText(1,1, \"%c{yellow}Javascript Roguelike\");\r\n        display.drawText(1,2, \"Press [Enter] to start!\");\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // When [Enter] is pressed, go to the play screen\r\n        if (inputType === 'keydown') {\r\n            if (inputData.keyCode === ROT.VK_RETURN) {\r\n                game.switchScreen(Screen.playScreen);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Define our playing screen\r\nScreen.playScreen = {\r\n    map: null,\r\n    player: null,\r\n    enter: () => {\r\n        // Keys for key handling\r\n        this.keys = {};\r\n        this.keys[ROT.VK_K] = 0;\r\n        this.keys[ROT.VK_UP] = 0;\r\n        this.keys[ROT.VK_NUMPAD8] = 0;\r\n        this.keys[ROT.VK_U] = 1;\r\n        this.keys[ROT.VK_NUMPAD9] = 1;\r\n        this.keys[ROT.VK_PAGE_UP] = 1;\r\n        this.keys[ROT.VK_L] = 2;\r\n        this.keys[ROT.VK_RIGHT] = 2;\r\n        this.keys[ROT.VK_NUMPAD6] = 2;\r\n        this.keys[ROT.VK_N] = 3;\r\n        this.keys[ROT.VK_NUMPAD3] = 3;\r\n        this.keys[ROT.VK_PAGE_DOWN] = 3;\r\n        this.keys[ROT.VK_J] = 4;\r\n        this.keys[ROT.VK_DOWN] = 4;\r\n        this.keys[ROT.VK_NUMPAD2] = 4;\r\n        this.keys[ROT.VK_B] = 5;\r\n        this.keys[ROT.VK_NUMPAD1] = 5;\r\n        this.keys[ROT.VK_END] = 5;\r\n        this.keys[ROT.VK_H] = 6;\r\n        this.keys[ROT.VK_LEFT] = 6;\r\n        this.keys[ROT.VK_NUMPAD4] = 6;\r\n        this.keys[ROT.VK_Y] = 7;\r\n        this.keys[ROT.VK_NUMPAD7] = 7;\r\n        this.keys[ROT.VK_HOME] = 7;\r\n\r\n        this.keys[ROT.VK_PERIOD] = -1;\r\n        this.keys[ROT.VK_CLEAR] = -1;\r\n        this.keys[ROT.VK_NUMPAD5] = -1;\r\n        this.move = (distance) => {\r\n            const newXY = this.player.xy.plus(distance);\r\n            // Try to move to the new cell\r\n            this.player.tryMove(newXY, this.map);\r\n        };\r\n        this.player = new Entity(PlayerTemplate);\r\n        this.map = GenerateMap(this.player);\r\n        this.map.engine.start();\r\n        console.log(\"Entered play screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited play screen.\");\r\n    },\r\n    render: (display) => {\r\n        const screenWidth = DisplayOptions.width;\r\n        const screenHeight = DisplayOptions.height;\r\n        // Make sure the x-axis doesn't go to the left of the left bound\r\n        let topLeftX = Math.max(0, this.player.xy.x - (screenWidth / 2));\r\n        // Make sure we still have enough space to fit an entire game screen\r\n        topLeftX = Math.floor(Math.min(topLeftX, this.map.width - screenWidth));\r\n        // Make sure the y-axis doesn't above the top bound\r\n        let topLeftY = Math.max(0, this.player.xy.y - (screenHeight / 2));\r\n        // Make sure we still have enough space to fit an entire game screen\r\n        topLeftY = Math.floor(Math.min(topLeftY, this.map.height - screenHeight));\r\n        // Iterate through all visible map cells\r\n        for (let x = topLeftX; x < topLeftX + screenWidth; x++) {\r\n            for (let y = topLeftY; y < topLeftY + screenHeight; y++) {\r\n                // Fetch the glyph for the tile and render it to the screen\r\n                // at the offset position.\r\n                const tile = this.map.getTile(new XY(x, y));\r\n                display.draw(\r\n                    x - topLeftX,\r\n                    y - topLeftY,\r\n                    tile.chr,\r\n                    tile.foreground,\r\n                    tile.background);\r\n            }\r\n        }\r\n        // Render the entities\r\n        const entities = this.map.entities;\r\n        for (var i = 0; i < entities.length; i++) {\r\n            var entity = entities[i];\r\n            // Only render the entity if they would show up on the screen\r\n            if (entity.xy.x >= topLeftX && entity.xy.y >= topLeftY &&\r\n                entity.xy.x < topLeftX + screenWidth &&\r\n                entity.xy.y < topLeftY + screenHeight) {\r\n                display.draw(\r\n                    entity.xy.x - topLeftX,\r\n                    entity.xy.y - topLeftY,\r\n                    entity.chr,\r\n                    entity.foreground,\r\n                    entity.background\r\n        );\r\n        // Get the messages in the player's queue and render them\r\n        const messages = this.player.messages;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            // Draw each message, adding the number of lines\r\n            display.drawText(\r\n                0,\r\n                i,\r\n                messages[i]\r\n            );\r\n        }\r\n        // Render player HP\r\n        const stats = vsprintf('HP: %d/%d ', [this.player.hp, this.player.maxHp]);\r\n        display.drawText(0, DisplayOptions.height - 1, stats);\r\n    }\r\n}\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        if (inputType === 'keydown') {\r\n            // If enter is pressed, go to the win screen\r\n            // If escape is pressed, go to lose screen\r\n            if (inputData.keyCode === ROT.VK_RETURN) {\r\n                game.switchScreen(Screen.winScreen);\r\n            } else if (inputData.keyCode === ROT.VK_ESCAPE) {\r\n                game.switchScreen(Screen.loseScreen);\r\n            } else {\r\n                // Movement\r\n                if (inputData.keyCode in this.keys) {\r\n            \t\tconst direction = this.keys[inputData.keyCode];\r\n            \t\tif (direction === -1) { // Wait 1 turn\r\n                        // Unlock the engine\r\n                        this.map.engine.unlock();\r\n            \t\t\treturn true;\r\n            \t\t}\r\n\r\n            \t\tconst dir = ROT.DIRS[8][direction];\r\n            \t\tthis.move(new XY(dir[0], dir[1]));\r\n\r\n                    // Unlock the engine\r\n                    this.map.engine.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Define our winning screen\r\nScreen.winScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered win screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited win screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        for (let i = 0; i < 22; i++) {\r\n            // Generate random background colors\r\n            const r = Math.round(Math.random() * 255);\r\n            const g = Math.round(Math.random() * 255);\r\n            const b = Math.round(Math.random() * 255);\r\n            const background = ROT.Color.toRGB([r, g, b]);\r\n            display.drawText(2, i + 1, \"%b{\" + background + \"}You win!\");\r\n        }\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // Nothing to do here\r\n    }\r\n}\r\n\r\n// Define our losing screen\r\nScreen.loseScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered lose screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited lose screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        for (var i = 0; i < 22; i++) {\r\n            display.drawText(2, i + 1, \"%b{red}You lose! :(\");\r\n        }\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // Nothing to do here\r\n    }\r\n}\r\n\r\nexport default Screen;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/screens.js","import Glyph from './glyph'\r\nimport {Tiles} from './const'\r\n\r\nexport default class Tile extends Glyph {\r\n    constructor(type) {\r\n        const properties = Tiles[type];\r\n        super(properties);\r\n        this.type = type;\r\n        this.isWalkable = properties[\"isWalkable\"] || false;\r\n        this.isDiggable = properties[\"isDiggable\"] || false;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tile.js","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 10\n// module chunks = 0","/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (Array.isArray(parse_tree[i])) {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                        break\n                    case 'e':\n                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(match[8])) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n                parse_tree.push(match)\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}()\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sprintf-js/src/sprintf.js\n// module id = 11\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 12\n// module chunks = 0","'use strict';\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  require('promise/lib/rejection-tracking').enable();\r\n  window.Promise = require('promise/lib/es6-extensions.js');\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\nrequire('whatwg-fetch');\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = require('object-assign');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./config/polyfills.js\n// module id = 13\n// module chunks = 0","import ROT from 'rot-js'\r\nimport game from './game';\r\n\r\nif (!ROT.isSupported()) {\r\n    alert(\"The rot.js library isn't supported by your browser.\");\r\n} else {\r\n    // Initialize the game\r\n    game.init();\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 15\n// module chunks = 0","import ROT from 'rot-js'\r\nimport Tile from './tile'\r\nimport XY from './xy'\r\nimport Entity from './entity'\r\nimport {FungusTemplate, EnemyTemplate} from './entities'\r\n\r\nexport default class Map {\r\n    constructor(tiles, player) {\r\n        this.tiles = tiles;\r\n        // cache the width and height based\r\n        // on the length of the dimensions of\r\n        // the tiles array\r\n        this.width = tiles.length;\r\n        this.height = tiles[0].length;\r\n        // create a list which will hold the entities\r\n        this.entities = [];\r\n        // create the engine and scheduler\r\n        this.scheduler = new ROT.Scheduler.Simple();\r\n        this.engine = new ROT.Engine(this.scheduler);\r\n        // add the player\r\n        this.addEntityAtRandomPosition(player);\r\n        // add random fungi\r\n        for (var i = 0; i < 50; i++) {\r\n            this.addEntityAtRandomPosition(new Entity(FungusTemplate));\r\n        }\r\n        // add enemy\r\n        this.addEntityAtRandomPosition(new Entity(EnemyTemplate));\r\n    }\r\n    getTile(xy) {\r\n        // Make sure we are inside the bounds. If we aren't, return\r\n        // null tile.\r\n        if (!this.isInBounds(xy)) {\r\n            return new Tile(\"null\");\r\n        } else {\r\n            return this.tiles[xy.x][xy.y] || new Tile(\"null\");\r\n        }\r\n    }\r\n    dig(xy) {\r\n        if (this.getTile(xy).isDiggable) {\r\n            this.tiles[xy.x][xy.y] = new Tile(\"floor\");\r\n        }\r\n    }\r\n    getRandomFloorTile() {\r\n        let x, y;\r\n        do {\r\n            x = Math.floor(ROT.RNG.getUniform() * this.width);\r\n            y = Math.floor(ROT.RNG.getUniform() * this.width);\r\n        } while(!this.isEmptyFloor(new XY(x, y)));\r\n        return new XY(x, y);\r\n    }\r\n    isInBounds(xy) {\r\n        return (xy.x > 0 && xy.x < this.width && xy.y > 0 && xy.y < this.height)\r\n    }\r\n    getEntityAt(xy) {\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            if (this.entities[i].xy.is(xy)) {\r\n                return this.entities[i];\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    addEntity(entity) {\r\n        // Make sure the entity's position is within bounds\r\n        if (!this.isInBounds(entity.xy)) {\r\n            throw new Error('Adding entity out of bounds.');\r\n        }\r\n        // Update the entity's map\r\n        entity.map = this;\r\n        // Add the entity to the list of entities\r\n        this.entities.push(entity);\r\n        // Check if this entity is an actor, and if so add\r\n        // them to the scheduler\r\n        if (entity.hasMixin('Actor')) {\r\n           this.scheduler.add(entity, true);\r\n        }\r\n    }\r\n    addEntityAtRandomPosition(entity) {\r\n        entity.xy = this.getRandomFloorTile();\r\n        this.addEntity(entity);\r\n    }\r\n    isEmptyFloor(xy) {\r\n        // Check if the tile is floor and also has no entity\r\n        return this.getTile(xy).type === \"floor\" && !this.getEntityAt(xy);\r\n    }\r\n    removeEntity(entity) {\r\n        // Find the entity in the list of entities if it is present\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            if (this.entities[i] === entity) {\r\n                this.entities.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        // If the entity is an actor, remove them from the scheduler\r\n        if (entity.hasMixin('Actor')) {\r\n            this.scheduler.remove(entity);\r\n        }\r\n    }\r\n    getEntitiesWithinRadius = function(centerXY, radius) {\r\n        let results = [];\r\n        // Determine our bounds\r\n        const leftX = centerXY.x - radius;\r\n        const rightX = centerXY.x + radius;\r\n        const topY = centerXY.y - radius;\r\n        const bottomY = centerXY.y + radius;\r\n        // Iterate through our entities, adding any which are within the bounds\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            if (this.entities[i].xy.x >= leftX &&\r\n                this.entities[i].xy.x <= rightX &&\r\n                this.entities[i].xy.y >= topY &&\r\n                this.entities[i].xy.y <= bottomY) {\r\n                results.push(this.entities[i]);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/map.js","import ROT from 'rot-js'\r\nimport Map from './map'\r\nimport {MapOptions} from './const'\r\nimport Tile from './tile'\r\n\r\nexport default function GenerateMap(player) {\r\n    let map = [];\r\n    for (let x = 0; x < MapOptions.width; x++) {\r\n        // Create the nested array for the y values\r\n        map.push([]);\r\n        // Add all the tiles\r\n        for (var y = 0; y < MapOptions.height; y++) {\r\n            map[x].push(new Tile(\"null\"));\r\n        }\r\n    }\r\n    // Setup the map generator\r\n    const generator = new ROT.Map.Digger(MapOptions.width, MapOptions.height);\r\n    generator.create((x, y, value) => {\r\n        if (value) {\r\n            map[x][y] = new Tile(\"wall\");\r\n        } else {\r\n            map[x][y] = new Tile(\"floor\");\r\n        }\r\n    });\r\n    // Create our map from the tiles\r\n    return new Map(map, player);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/mapgen.js","import Mixins from './mixins.js'\r\nimport sprintfjs from 'sprintf-js'\r\n\r\nconst vsprintf = sprintfjs.vsprintf;\r\nconst sprintf = sprintfjs.sprintf;\r\n\r\nexport function sendMessage(recipient, message, args) {\r\n    // Make sure the recipient can receive the message\r\n    // before doing any work.\r\n    if (recipient.hasMixin(Mixins.MessageRecipient)) {\r\n        // If args were passed, then we format the message, else\r\n        // no formatting is necessary\r\n        if (args) {\r\n            message = vsprintf(message, args);\r\n        }\r\n        recipient.receiveMessage(message);\r\n    }\r\n}\r\n\r\nexport function sendMessageNearby(map, centerXY, message, args) {\r\n    // Get the nearby entities\r\n    const entities = map.getEntitiesWithinRadius(centerXY, 5);\r\n    // Iterate through nearby entities, sending the message if\r\n    // they can receive it.\r\n    for (let i = 0; i < entities.length; i++) {\r\n        sendMessage(entities[i], message, args)\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/msg.js","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dice = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"dice.js\",\n  \"version\": \"0.9.3\",\n  \"description\": \"A parser and evaluator for a useful rpg dice syntax.\",\n  \"main\": \"build/dice.js\",\n  \"directories\": {\n    \"test\": \"tests\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"browserify\": \"~14.1.0\",\n    \"jasmine-core\": \"^2.5.2\",\n    \"jasmine-node\": \"~1.14.5\",\n    \"karma\": \"~1.5.0\",\n    \"karma-chrome-launcher\": \"~2.0\",\n    \"karma-firefox-launcher\": \"~1.0.1\",\n    \"karma-jasmine\": \"~1.1\",\n    \"karma-phantomjs-launcher\": \"~1.0.4\",\n    \"pegjs\": \"~0.10.0\"\n  },\n  \"scripts\": {\n    \"test\": \"make test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/lordnull/dice.js.git\"\n  },\n  \"keywords\": [\n    \"rpg\",\n    \"dice\",\n    \"parser\",\n    \"roll\",\n    \"peg\"\n  ],\n  \"author\": \"Micah Warren (Lord Null)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/lordnull/dice.js/issues\"\n  },\n  \"homepage\": \"https://github.com/lordnull/dice.js\"\n}\n\n},{}],2:[function(require,module,exports){\nvar dice = {\n\tparse: require('./parser').parse,\n\teval: require('./evaluate').eval,\n\tops: require('./evaluate').ops,\n\tversion: require('../package').version\n};\n\nfunction roll(str, scope){\n\tvar parsed = dice.parse(str);\n\tvar evaled = dice.eval(parsed, scope);\n\treturn evaled;\n};\n\ndice.roll = roll;\n\ndice.statistics = function(str, scope, samples){\n\tif(typeof(scope) == \"number\"){\n\t\tsamples = scope;\n\t\tscope = {};\n\t}\n\tscope = scope || {};\n\tsamples = samples || 1000;\n\tvar resultSet = [];\n\tvar i;\n\tfor(i = 0; i < samples; i++){\n\t\tresultSet.push(roll(str, scope));\n\t}\n\tvar mean = resultSet.reduce(function(n, acc){ return n + acc; }, 0) / samples;\n\tvar min = resultSet.reduce(function(n, acc){ return n < acc ? n : acc; }, resultSet[0]);\n\tvar max = resultSet.reduce(function(n, acc){ return n > acc ? n : acc; }, resultSet[0]);\n\n\tvar parsed = dice.parse(str);\n\n\tvar minMaxPossible = determine_min_max_possible(parsed, scope);\n\n\treturn {\n\t\t'results': resultSet,\n\t\t'mean': mean,\n\t\t'min': parseInt(min.toFixed()),\n\t\t'max': parseInt(max.toFixed()),\n\t\t'min_possible': minMaxPossible[0],\n\t\t'max_possible': minMaxPossible[1]\n\t};\n};\n\nfunction determine_min_max_possible(opObject, scope){\n\tif(opObject.op == 'static'){\n\t\treturn [opObject.value, opObject.value];\n\t}\n\tif(opObject.op == 'lookup'){\n\t\tvar lookup = dice.ops.lookup.call(opObject, scope);\n\t\treturn [lookup(scope), lookup(scope)];\n\t}\n\tif(opObject.op == 'floor'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.floor(minmax[0]), Math.floor(minmax[1])];\n\t}\n\tif(opObject.op == 'ceil'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.ceil(minmax[0]), Math.ceil(minmax[1])];\n\t}\n\tif(opObject.op == 'round'){\n\t\tvar minmax = determine_min_max_possible(opObject.args[0], scope);\n\t\treturn [Math.round(minmax[0]), Math.round(minmax[1])];\n\t}\n\tif(opObject.op == 'd'){\n\t\tvar multipleMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar randPartMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = randPartMinMax[0] * multipleMinMax[0];\n\t\tvar max = randPartMinMax[1] * multipleMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'w'){\n\t\tvar multipleMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar randPartMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = randPartMinMax[0] * multipleMinMax[0];\n\t\tvar max = randPartMinMax[1] * multipleMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'random'){\n\t\tvar minMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar maxMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\treturn [minMinMax[0], maxMinMax[1]];\n\t}\n\tif(opObject.op == '+'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] + rightMinMax[0];\n\t\tvar max = leftMinMax[1] + rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '-'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] - rightMinMax[0];\n\t\tvar max = leftMinMax[1] - rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '*'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] * rightMinMax[0];\n\t\tvar max = leftMinMax[1] * rightMinMax[1];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == '/'){\n\t\tvar leftMinMax = determine_min_max_possible(opObject.args[0], scope);\n\t\tvar rightMinMax = determine_min_max_possible(opObject.args[1], scope);\n\t\tvar min = leftMinMax[0] / rightMinMax[1];\n\t\tvar max = leftMinMax[1] / rightMinMax[0];\n\t\treturn [min, max];\n\t}\n\tif(opObject.op == 'paren_express'){\n\t\treturn determine_min_max_possible(opObject.args[0], scope);\n\t}\n}\n\nfunction stringify_expression(evaled_op){\n\tvar sub = stringify(evaled_op.expression);\n\tvar prefix = evaled_op.op[0];\n\tif(prefix === 'p'){\n\t\tprefix = '';\n\t}\n\t\n\treturn prefix + \"( \" + sub + \" )\";\n};\n\nfunction stringify_op(evaled_op){\n\tvar rs = stringify(evaled_op.rightSide);\n\tvar ls = stringify(evaled_op.leftSide);\n\treturn rs + ' ' + evaled_op.op + ' ' + ls;\n};\n\nfunction stringify_rolls(evaled_roll){\n\tvar minStr = evaled_roll.min > 1 ? evaled_roll.min + '..' : '';\n\tvar preamble = evaled_roll.x + evaled_roll.mode + minStr + evaled_roll.max + ':[';\n\treturn preamble + evaled_roll.rolls.join(', ') + ']';\n};\n\nfunction stringify(evaled){\n\tif(evaled.expression){\n\t\treturn stringify_expression(evaled);\n\t}\n\n\tif(evaled.op){\n\t\treturn stringify_op(evaled);\n\t}\n\n\tif(evaled.rolls){\n\t\treturn stringify_rolls(evaled);\n\t}\n\n\treturn evaled.toString();\n};\n\ndice.stringify = stringify;\n\nvar k;\nfor(k in dice){\n    exports[k] = dice[k];\n}\n\n\n},{\"../package\":1,\"./evaluate\":3,\"./parser\":4}],3:[function(require,module,exports){\n\nfunction makeSeq(endIndex){\n\tvar seq = [];\n\tseq[endIndex] = true;\n\tfor(var i = 0; i < seq.length; i++){\n\t\tseq[i] = true;\n\t}\n\treturn seq;\n};\n\nvar ops = {\n\n\t'static': function(){\n\t\tvar outValue = this.value;\n\t\treturn function(){\n\t\t\treturn outValue;\n\t\t};\n\t},\n\n\t'lookup': function(){\n\t\tvar variableName = this.value;\n\t\treturn function(scope){\n\t\t\tvar undef;\n\t\t\tvar out = scope[variableName];\n\t\t\tif(out != undef){\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\tvar split = variableName.split('.');\n\t\t\tif(variableName == split){\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\treduceRes = split.reduce(function(acc, elem){\n\t\t\t\tif(acc == undef){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn acc[elem];\n\t\t\t}, scope);\n\t\t\treturn reduceRes;\n\t\t}\n\t},\n\n\t'floor': function(value){\n\t\treturn function(scope){\n\t\t\tvar floorable = value(scope);\n\t\t\tvar tots = new Number(Math.floor(floorable));\n\t\t\ttots.op = 'floor';\n\t\t\ttots.expression = floorable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'ceil': function(value){\n\t\treturn function(scope){\n\t\t\tvar ceilable = value(scope);\n\t\t\tvar tots = new Number(Math.ceil(ceilable));\n\t\t\ttots.op = 'ceil';\n\t\t\ttots.expression = ceilable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'round': function(value){\n\t\treturn function(scope){\n\t\t\tvar roundable = value(scope);\n\t\t\tvar tots = new Number(Math.round(roundable));\n\t\t\ttots.op = 'round';\n\t\t\ttots.expression = roundable;\n\t\t\treturn tots;\n\t\t}\n\t},\n\n\t'd': function(numRolls, minMax){\n\t\treturn function(scope){\n\t\t\tvar x = numRolls(scope);\n\t\t\tvar seq = makeSeq(x - 1);\n\t\t\tvar outMin, outMax;\n\t\t\tvar rolled = seq.map(function(){\n\t\t\t\tvar rolledRet = minMax(scope);\n\t\t\t\toutMin = rolledRet.min;\n\t\t\t\toutMax = rolledRet.max;\n\t\t\t\treturn rolledRet;\n\t\t\t});\n\t\t\tvar out = rolled.reduce(function(sum, val){\n\t\t\t\treturn sum + val;\n\t\t\t}, 0);\n\t\t\tout = new Number(out);\n\t\t\tout.rolls = rolled;\n\t\t\tout.min = outMin;\n\t\t\tout.max = outMax;\n\t\t\tout.x = x;\n\t\t\tout.mode = 'd';\n\t\t\treturn out;\n\t\t};\n\t},\n\n\t'w': function(numRolls, minMax){\n\t\treturn function(scope){\n\t\t\tvar x = numRolls(scope);\n\t\t\tvar seq = makeSeq(x - 1);\n\t\t\tvar outMin, outMax;\n\t\t\tvar rolled = seq.map(function(){\n\t\t\t\tvar lastRolled = minMax(scope);\n\t\t\t\tvar wildrolled = 0;\n\t\t\t\toutMin = minMax.min;\n\t\t\t\toutMax = minMax.max;\n\t\t\t\tif(minMax.min === minMax.max){\n\t\t\t\t\treturn lastRolled;\n\t\t\t\t}\n\t\t\t\twhile(lastRolled === minMax.max){\n\t\t\t\t\twildrolled += lastRolled;\n\t\t\t\t\tlastRolled = mimMax(scope);\n\t\t\t\t}\n\t\t\t\treturn wildrolled;\n\t\t\t});\n\t\t\tvar out = rolled.reduce(function(sum, val){\n\t\t\t\treturn sum + val;\n\t\t\t}, 0);\n\t\t\tout = new Number(out);\n\t\t\tout.rolls = rolled;\n\t\t\tout.min = outMin;\n\t\t\tout.max = outMax;\n\t\t\tout.x = x;\n\t\t\tout.mode = 'w';\n\t\t\treturn out;\n\t\t};\n\t},\n\n\t'random': function(minFun, maxFun){\n\t\treturn function(scope){\n\t\t\tvar rawRandom = Math.random();\n\t\t\tvar max = maxFun(scope);\n\t\t\tvar min = minFun(scope);\n\t\t\tvar diff = max - min;\n\t\t\tvar rawRandom = diff * rawRandom;\n\t\t\tvar rndNumber = Math.round(rawRandom + min);\n\t\t\trndNumber = new Number(rndNumber);\n\t\t\trndNumber.min = min;\n\t\t\trndNumber.max = max;\n\t\t\treturn rndNumber;\n\t\t};\n\t},\n\n\t'+': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar sum = rightSide + leftSide;\n\t\t\tsum = new Number(sum);\n\t\t\tsum.op = '+';\n\t\t\tsum.rightSide = rightSide;\n\t\t\tsum.leftSide = leftSide;\n\t\t\treturn sum;\n\t\t};\n\t},\n\n\t'-': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar sum = rightSide - leftSide;\n\t\t\tsum = new Number(sum);\n\t\t\tsum.op = '-';\n\t\t\tsum.rightSide = rightSide;\n\t\t\tsum.leftSide = leftSide;\n\t\t\treturn sum;\n\t\t};\n\t},\n\n\t'*': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar tots = rightSide * leftSide;\n\t\t\ttots = new Number(tots);\n\t\t\ttots.op = '*';\n\t\t\ttots.rightSide = rightSide;\n\t\t\ttots.leftSide = leftSide;\n\t\t\treturn tots;\n\t\t};\n\t},\n\n\t'/': function(v1, v2){\n\t\treturn function(scope){\n\t\t\tvar rightSide = v1(scope);\n\t\t\tvar leftSide = v2(scope);\n\t\t\tvar tots = rightSide / leftSide;\n\t\t\ttots = new Number(tots);\n\t\t\ttots.op = '/';\n\t\t\ttots.rightSide = rightSide;\n\t\t\ttots.leftSide = leftSide;\n\t\t\treturn tots;\n\t\t};\n\t},\n\n\t'paren_express': function(op){\n\t\treturn function(scope){\n\t\t\tvar tots = op(scope);\n\t\t\touttots = new Number(tots);\n\t\t\touttots.op = 'paren_express';\n\t\t\touttots.expression = tots;\n\t\t\treturn outtots;\n\t\t};\n\t}\n\n};\n\nfunction resolve_ops(args){\n\targs = args || [];\n\treturn args.map(resolve_op);\n};\n\nfunction resolve_op(opObj){\n\tvar subArgs = resolve_ops(opObj.args);\n\treturn ops[opObj.op].apply(opObj, subArgs);\n};\n\n\nexports.eval = function(parsed, scope){\n\tscope = scope || {};\n\tvar ops = resolve_op(parsed)\n\treturn ops(scope);\n\n\t/*var acc = {sum: 0, mode: \"+\", rolls: [], 'scope':scope}\n\tvar reduced = parsed.reduce(reduceThemBones, acc);\n\treturn {sum: reduced.sum, rolls: reduced.rolls};*/\n}\n\nexports.ops = ops;\n\n\n},{}],4:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = function(v1, op, v2) { return {'op':op, args: [v1, v2] }; },\n      peg$c1 = function(out) { return out; },\n      peg$c2 = \"(\",\n      peg$c3 = peg$literalExpectation(\"(\", false),\n      peg$c4 = \")\",\n      peg$c5 = peg$literalExpectation(\")\", false),\n      peg$c6 = function(rolls) { return {'op':'paren_express', args: [rolls]} },\n      peg$c7 = \"*\",\n      peg$c8 = peg$literalExpectation(\"*\", false),\n      peg$c9 = function() { return '*'; },\n      peg$c10 = \"/\",\n      peg$c11 = peg$literalExpectation(\"/\", false),\n      peg$c12 = function() { return '/'; },\n      peg$c13 = function(v1, op, v2) { return {'op':op, args:[v1, v2] }; },\n      peg$c14 = function(d) { return d; },\n      peg$c15 = function(paren) { return paren; },\n      peg$c16 = function(v1, op, v2) { return {'op':op, args:[v1, v2]}; },\n      peg$c17 = function(op) { return op; },\n      peg$c18 = \"+\",\n      peg$c19 = peg$literalExpectation(\"+\", false),\n      peg$c20 = function() { return \"+\"; },\n      peg$c21 = \"-\",\n      peg$c22 = peg$literalExpectation(\"-\", false),\n      peg$c23 = function() { return \"-\"; },\n      peg$c24 = function(x, mode, mm) { return {'op':mode, 'args':[x, mm]} },\n      peg$c25 = function(mode, mm) { return {'op':mode, 'args':[{'op':'static', 'value':1}, mm]}; },\n      peg$c26 = function(mm) { return { 'op':'d', 'args':[ {'op':'static', 'value':1}, mm]}; },\n      peg$c27 = function(x) { return x; },\n      peg$c28 = \"d\",\n      peg$c29 = peg$literalExpectation(\"d\", false),\n      peg$c30 = \"w\",\n      peg$c31 = peg$literalExpectation(\"w\", false),\n      peg$c32 = function(mm) { return mm; },\n      peg$c33 = function(max) { return {'op':'random', 'args':[{'op':'static', 'args':[], 'value':1}, max]}; },\n      peg$c34 = \"..\",\n      peg$c35 = peg$literalExpectation(\"..\", false),\n      peg$c36 = function(min, max) { return {'op':'random', 'args':[min, max]}; },\n      peg$c37 = /^[ ]/,\n      peg$c38 = peg$classExpectation([\" \"], false, false),\n      peg$c39 = function(i) {\n      \t\treturn {'op': 'static', value: i};\n      \t},\n      peg$c40 = function(l) {\n      \t\treturn l;\n      \t},\n      peg$c41 = function(f, v) {\n      \t\treturn {'op':f, args:[v]};\n      \t},\n      peg$c42 = function(f, ex) {\n          return {'op':f, args:ex.args};\n      \t},\n      peg$c43 = \"f\",\n      peg$c44 = peg$literalExpectation(\"f\", false),\n      peg$c45 = function() { return 'floor'; },\n      peg$c46 = \"r\",\n      peg$c47 = peg$literalExpectation(\"r\", false),\n      peg$c48 = function() { return 'round'; },\n      peg$c49 = \"c\",\n      peg$c50 = peg$literalExpectation(\"c\", false),\n      peg$c51 = function() { return 'ceil'; },\n      peg$c52 = function(v) { return {'op':'lookup', 'value':v}; },\n      peg$c53 = \"[\",\n      peg$c54 = peg$literalExpectation(\"[\", false),\n      peg$c55 = /^[^[\\]]/,\n      peg$c56 = peg$classExpectation([\"[\", \"]\"], true, false),\n      peg$c57 = \"]\",\n      peg$c58 = peg$literalExpectation(\"]\", false),\n      peg$c59 = function(varname) { return varname.join(\"\"); },\n      peg$c60 = peg$otherExpectation(\"integer\"),\n      peg$c61 = /^[0-9]/,\n      peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c63 = function(digits) { return parseInt(digits.join(\"\"), 10); },\n      peg$c64 = function(digits) { return parseInt(digits.join(\"\"), 10) * -1; },\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsedicerolls();\n\n    return s0;\n  }\n\n  function peg$parsedicerolls() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiplicationSeq();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseadditionOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseadditionSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseadditionSeq();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseparenExpress();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseparenExpress() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c2;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsews();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedicerolls();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsews();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c4;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c6(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicationOp() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsews();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s2 = peg$c7;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsews();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c10;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsews();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c12();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicationSeq() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsediceroll();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemultiplicationOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemultiplicationSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseparenExpress();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemultiplicationOp();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsemultiplicationSeq();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsediceroll();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c14(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseparenExpress();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c15(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditionSeq() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiplicationSeq();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseadditionOp();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseadditionSeq();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsemultiplicationSeq();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseparenExpress();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c17(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditionOp() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsews();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s2 = peg$c18;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsews();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c21;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsews();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c23();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsediceroll() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseintval();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parserollmode();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemaybe_minmax();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parserollmode();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemaybe_minmax();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseminmax();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c26(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseintval();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c27(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parserollmode() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 100) {\n      s0 = peg$c28;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 119) {\n        s0 = peg$c30;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemaybe_minmax() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseminmax();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseintval();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseminmax() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseintval();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c34) {\n        s2 = peg$c34;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseintval();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c36(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c37.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c38); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c37.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintval() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseinteger();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c39(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parselookup();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c40(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsemathit();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parselookup();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c41(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemathit();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseparenExpress();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c42(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemathit() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 102) {\n      s1 = peg$c43;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c45();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 114) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 99) {\n          s1 = peg$c49;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c51();\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parselookup() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsevariable();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c52(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsevariable() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c53;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$c55.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c56); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c55.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c57;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c58); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c59(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseinteger() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c61.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c63(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c62); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c64(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c60); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n},{}]},{},[2])(2)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dice.js/build/dice.js\n// module id = 19\n// module chunks = 0","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 20\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 21\n// module chunks = 0","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/rejection-tracking.js\n// module id = 23\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 24\n// module chunks = 0"],"sourceRoot":""}