{"version":3,"sources":["..\\static\\js\\main.7de81c26.js","..\\webpack\\bootstrap e4e52588555cb83c4ac2","game.js","xy.js","entity.js","..\\node_modules\\rot-js\\lib\\rot.js","being.js","..\\node_modules\\promise\\lib\\core.js","..\\node_modules\\webpack\\buildin\\global.js","..\\config\\polyfills.js","index.js","..\\node_modules\\asap\\browser-raw.js","level.js","player.js","textbuffer.js","..\\node_modules\\object-assign\\index.js","..\\node_modules\\process\\browser.js","..\\node_modules\\promise\\lib\\es6-extensions.js","..\\node_modules\\promise\\lib\\rejection-tracking.js","..\\node_modules\\whatwg-fetch\\fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_rot_js__","__WEBPACK_IMPORTED_MODULE_0_rot_js___default","__WEBPACK_IMPORTED_MODULE_3__level__","__WEBPACK_IMPORTED_MODULE_4__player__","__WEBPACK_IMPORTED_MODULE_5__textbuffer__","__WEBPACK_IMPORTED_MODULE_6__xy__","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Game","this","window","addEventListener","e","type","removeEventListener","scheduler","a","Scheduler","Speed","engine","Engine","display","Display","fontSize","textBuffer","document","body","appendChild","getContainer","player","level","size","getSize","_switchLevel","setEntity","Math","round","x","y","start","xy","entity","getEntityAt","visual","getVisual","draw","ch","fg","bg","lock","clear","setOptions","width","height","configure","position","j","beings","getBeings","add","game","XY","arguments","undefined","dx","dy","max","abs","sqrt","Entity","_visual","_xy","_level","global","process","requestAnimationFrame","cb","setTimeout","child","scrollLeft","scrollTop","createElement","canvas","getBoundingClientRect","left","top","getContext","_termcolor","beginPath","clearRect","w","h","clearCmd","clearToAnsi","fillStyle","stdout","write","drawImage","b","f","g","fill","fillRect","fillText","chs","font","lineTo","measureText","moveTo","textAlign","textBaseline","style","visibility","documentElement","ROT","isSupported","Function","bind","DEFAULT_WIDTH","DEFAULT_HEIGHT","DIRS","4","8","6","VK_CANCEL","VK_HELP","VK_BACK_SPACE","VK_TAB","VK_CLEAR","VK_RETURN","VK_ENTER","VK_SHIFT","VK_CONTROL","VK_ALT","VK_PAUSE","VK_CAPS_LOCK","VK_ESCAPE","VK_SPACE","VK_PAGE_UP","VK_PAGE_DOWN","VK_END","VK_HOME","VK_LEFT","VK_UP","VK_RIGHT","VK_DOWN","VK_PRINTSCREEN","VK_INSERT","VK_DELETE","VK_0","VK_1","VK_2","VK_3","VK_4","VK_5","VK_6","VK_7","VK_8","VK_9","VK_COLON","VK_SEMICOLON","VK_LESS_THAN","VK_EQUALS","VK_GREATER_THAN","VK_QUESTION_MARK","VK_AT","VK_A","VK_B","VK_C","VK_D","VK_E","VK_F","VK_G","VK_H","VK_I","VK_J","VK_K","VK_L","VK_M","VK_N","VK_O","VK_P","VK_Q","VK_R","VK_S","VK_T","VK_U","VK_V","VK_W","VK_X","VK_Y","VK_Z","VK_CONTEXT_MENU","VK_NUMPAD0","VK_NUMPAD1","VK_NUMPAD2","VK_NUMPAD3","VK_NUMPAD4","VK_NUMPAD5","VK_NUMPAD6","VK_NUMPAD7","VK_NUMPAD8","VK_NUMPAD9","VK_MULTIPLY","VK_ADD","VK_SEPARATOR","VK_SUBTRACT","VK_DECIMAL","VK_DIVIDE","VK_F1","VK_F2","VK_F3","VK_F4","VK_F5","VK_F6","VK_F7","VK_F8","VK_F9","VK_F10","VK_F11","VK_F12","VK_F13","VK_F14","VK_F15","VK_F16","VK_F17","VK_F18","VK_F19","VK_F20","VK_F21","VK_F22","VK_F23","VK_F24","VK_NUM_LOCK","VK_SCROLL_LOCK","VK_CIRCUMFLEX","VK_EXCLAMATION","VK_DOUBLE_QUOTE","VK_HASH","VK_DOLLAR","VK_PERCENT","VK_AMPERSAND","VK_UNDERSCORE","VK_OPEN_PAREN","VK_CLOSE_PAREN","VK_ASTERISK","VK_PLUS","VK_PIPE","VK_HYPHEN_MINUS","VK_OPEN_CURLY_BRACKET","VK_CLOSE_CURLY_BRACKET","VK_TILDE","VK_COMMA","VK_PERIOD","VK_SLASH","VK_BACK_QUOTE","VK_OPEN_BRACKET","VK_BACK_SLASH","VK_CLOSE_BRACKET","VK_QUOTE","VK_META","VK_ALTGR","VK_WIN","VK_KANA","VK_HANGUL","VK_EISU","VK_JUNJA","VK_FINAL","VK_HANJA","VK_KANJI","VK_CONVERT","VK_NONCONVERT","VK_ACCEPT","VK_MODECHANGE","VK_SELECT","VK_PRINT","VK_EXECUTE","VK_SLEEP","Text","RE_COLORS","TYPE_TEXT","TYPE_NEWLINE","TYPE_FG","TYPE_BG","measure","str","maxWidth","result","tokens","tokenize","lineWidth","token","offset","replace","match","index","part","substring","push","trim","_breakLines","Infinity","lineLength","lastTokenWithSpace","charAt","indexOf","_breakInsideToken","arr","split","pop","join","nextIndex","breakIndex","lastIndexOf","splice","lastTextToken","tokenIndex","removeBreakChar","newBreakToken","newTextToken","Array","random","floor","RNG","getUniform","randomize","Number","mod","String","capitalize","toUpperCase","lpad","character","count","cnt","rpad","format","template","map","args","slice","replacer","group1","group2","obj","group","parts","shift","method","toLowerCase","replaced","apply","first","unshift","create","tmp","extend","parent","constructor","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","options","_context","_data","_dirty","_options","_backend","defaultOptions","transpose","layout","spacing","border","forceSquareRatio","fontFamily","fontStyle","tileWidth","tileHeight","tileMap","tileSet","tileColorize","termColor","DEBUG","_tick","what","colors","compute","getOptions","computeSize","availWidth","availHeight","computeFontSize","eventToPosition","touches","clientX","clientY","rect","drawText","text","cx","cy","lines","isSpace","isPrevSpace","isFullWidth","isPrevFullWidth","cc","charCodeAt","_draw","clearBefore","data","Backend","context","Rect","_spacingX","_spacingY","_canvasCache","cache","charWidth","ceil","_drawWithCache","_drawNoCache","hash","ctx","chars","concat","boxWidth","boxHeight","oldFont","ratio","widthFraction","Hex","_hexSize","xprop","yprop","px","reverse","_fill","hexSizeWidth","hexSizeHeight","hexSize","min","prop","Tile","_colorCanvas","tile","Error","globalCompositeOperation","getSeed","_seed","setSeed","seed","_s0","_frac","_s1","_s2","_c","t","getUniformInt","lowerBound","upperBound","getNormal","mean","stddev","u","v","r","gauss","log","getPercentage","getWeightedValue","total","getState","setState","state","clone","Date","now","StringGenerator","words","order","prior","_boundary","fromCharCode","_suffix","_prefix","_priorValues","generate","_sample","_join","observe","string","_split","event","subcontext","_observeEvent","getStats","priorCount","dataCount","eventCount","_backoff","available","EventQueue","_time","_events","_eventTimes","getTime","time","remove","_remove","_queue","_repeat","_current","item","repeat","next","Simple","getSpeed","Action","_defaultDuration","_duration","setDuration","_scheduler","_lock","unlock","actor","act","then","Map","_width","_height","callback","_fillMap","Arena","empty","DividedMaze","_stack","_map","_process","room","_partitionRoom","availX","availY","bottom","right","walls","solid","hole","IceyMaze","regularity","_regularity","nx","ny","done","blocked","dirs","_randomize","_isFree","EllerMaze","L","R","_addToList","_removeFromList","Cellular","born","survive","topology","connected","_dirs","probability","set","newMap","widthStep","widthStart","cur","ncount","_getNeighbors","_completeMaze","dir","allFreeSpace","notConnected","_freeSpace","_pointKey","_findConnected","keys","_getFromTo","from","to","local","_tunnelToConnected","k","pp","connectedKeys","notConnectedKeys","_getClosest","point","space","minPoint","minDist","stack","keepNotConnected","tests","xx","pkey","yy","Dungeon","_rooms","_corridors","getRooms","getCorridors","Digger","roomWidth","roomHeight","corridorLength","dugPercentage","timeLimit","_features","Room","Corridor","_featureAttempts","_walls","_digCallback","_canBeDugCallback","_isWallCallback","_priorityWallCallback","_dug","area","_firstRoom","t1","wall","_findWall","parseInt","_getDiggingDirection","featureAttempts","_tryFeature","_removeSurroundingWalls","priorityWalls","_addDoors","Feature","createRandomCenter","prio1","prio2","feature","createRandomAt","isValid","createPriorityWalls","deltas","delta","isWallCallback","clearDoors","addDoors","Uniform","roomDugPercentage","_roomAttempts","_corridorAttempts","_connected","_unconnected","_generateRooms","_generateCorridors","_generateRoom","createRandom","room1","_closestRoom","room2","_connectRooms","rooms","dist","center","getCenter","center1","center2","diffX","diffY","dirIndex1","dirIndex2","getLeft","getRight","getTop","getBottom","_placeInWall","end","_digLine","diff","rotation","mid","index2","mid1","mid2","addDoor","dirIndex","avail","lastBadIndex","points","corridor","Rogue","cellWidth","cellHeight","_calculateRoomSize","connectedCells","_initRooms","_connectUnconnectedRooms","_createRandomRoomConnections","_createRooms","_createCorridors","cell","connections","cellx","celly","idx","ncgx","ncgy","otherRoom","cgx","cgy","found","dirToCheck","cw","validRoom","directions","dirIdx","newI","newJ","console","roomw","roomh","sx","sy","cwp","chp","sxOffset","syOffset","ii","jj","_getWallPosition","aRoom","aDirection","rx","ry","door","_drawCorridore","startPosition","endPosition","tempDist","xDir","yDir","move","xOffset","yOffset","xpos","ypos","moves","xAbs","yAbs","percent","firstHalf","secondHalf","connection","otherWall","canBeDugCallback","digCallback","debug","x1","y1","x2","y2","doorX","doorY","_x1","_y1","_x2","_y2","_doors","getDoors","startX","startY","endX","endY","_startX","_startY","_endX","_endY","_endsWithAWall","ok","firstCornerBad","secondCornerBad","priorityWallCallback","Noise","Simplex","gradients","_F2","_G2","_gradients","permutations","_perms","_indexes","xin","yin","gi","i1","j1","perms","indexes","G2","n0","n1","n2","X0","Y0","x0","y0","t0","grad","t2","FOV","lightPassesCallback","_lightPasses","_getCircle","countFactor","startOffset","DiscreteShadowcasting","_coords","A","B","blocks","DATA","neighbors","angle","_visibleCoords","v1","callee","v2","PreciseShadowcasting","A1","A2","SHADOWS","neighborCount","_checkVisibility","index1","edge1","old","edge2","visible","visibleLength","P","P1","P2","RecursiveShadowcasting","OCTANTS","_renderOctant","compute180","previousOctant","nextPreviousOctant","nextOctant","compute90","octant","_castVisibility","row","visSlopeStart","visSlopeEnd","radius","yx","newStart","mapX","mapY","slopeStart","slopeEnd","Color","fromString","cached","_cache","values","color1","color2","add_","multiply","multiply_","interpolate","factor","interpolateHSL","hsl1","rgb2hsl","hsl2","hsl2rgb","color","hue2rgb","q","toRGB","_clamp","toHex","toString","num","black","navy","darkblue","mediumblue","blue","darkgreen","green","teal","darkcyan","deepskyblue","darkturquoise","mediumspringgreen","lime","springgreen","aqua","cyan","midnightblue","dodgerblue","forestgreen","seagreen","darkslategray","darkslategrey","limegreen","mediumseagreen","turquoise","royalblue","steelblue","darkslateblue","mediumturquoise","indigo","darkolivegreen","cadetblue","cornflowerblue","mediumaquamarine","dimgray","dimgrey","slateblue","olivedrab","slategray","slategrey","lightslategray","lightslategrey","mediumslateblue","lawngreen","chartreuse","aquamarine","maroon","purple","olive","gray","grey","skyblue","lightskyblue","blueviolet","darkred","darkmagenta","saddlebrown","darkseagreen","lightgreen","mediumpurple","darkviolet","palegreen","darkorchid","yellowgreen","sienna","brown","darkgray","darkgrey","lightblue","greenyellow","paleturquoise","lightsteelblue","powderblue","firebrick","darkgoldenrod","mediumorchid","rosybrown","darkkhaki","silver","mediumvioletred","indianred","peru","chocolate","tan","lightgray","lightgrey","palevioletred","thistle","orchid","goldenrod","crimson","gainsboro","plum","burlywood","lightcyan","lavender","darksalmon","violet","palegoldenrod","lightcoral","khaki","aliceblue","honeydew","azure","sandybrown","wheat","beige","whitesmoke","mintcream","ghostwhite","salmon","antiquewhite","linen","lightgoldenrodyellow","oldlace","red","fuchsia","magenta","deeppink","orangered","tomato","hotpink","coral","darkorange","lightsalmon","orange","lightpink","pink","gold","peachpuff","navajowhite","moccasin","bisque","mistyrose","blanchedalmond","papayawhip","lavenderblush","seashell","cornsilk","lemonchiffon","floralwhite","snow","yellow","lightyellow","ivory","white","Lighting","reflectivityCallback","_reflectivityCallback","passes","emissionThreshold","range","_fov","_lights","_reflectivityCache","_fovCache","reset","setFOV","fov","setLight","clearLights","lightingCallback","doneCells","emittingCells","litCells","light","_emitLight","_computeEmitters","litKey","_emitLightFromCell","reflectivity","emission","intensity","_updateFOV","fovKey","formFactor","key1","vis","key2","Path","toX","toY","passableCallback","_toX","_toY","_fromX","_fromY","_passableCallback","fromX","fromY","Dijkstra","_computed","_todo","_add","_compute","prev","neighbor","AStar","_done","_distance","Term","_cx","_cy","_lastColor","_ox","_oy","columns","rows","positionToAnsi","newColor","colorToAnsi","Xterm","rgb","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__entity__","__WEBPACK_IMPORTED_MODULE_1__game__","Being","_Entity","_this","getPrototypeOf","setPosition","_speed","_hp","damage","die","noop","getThen","ex","LAST_ERROR","IS_ERROR","tryCallOne","fn","tryCallTwo","Promise","_45","_81","_65","_54","doResolve","safeThen","onFulfilled","onRejected","resolve","reject","res","handle","Handler","deferred","_10","handleResolved","asap","promise","ret","newValue","finale","_97","reason","_61","eval","enable","assign","init","alert","rawAsap","task","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromTimer","handleTimer","timeoutHandle","clearInterval","intervalHandle","setInterval","scope","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","toggle","observer","node","createTextNode","characterData","__WEBPACK_IMPORTED_MODULE_2__xy__","Level","_beings","_size","_empty","getLevel","oldXY","getXY","__WEBPACK_IMPORTED_MODULE_1__being__","__WEBPACK_IMPORTED_MODULE_2__game__","__WEBPACK_IMPORTED_MODULE_3__xy__","_get","receiver","desc","getOwnPropertyDescriptor","Player","_Being","_handleKey","code","_keys","direction","plus","over","keyCode","__WEBPACK_IMPORTED_MODULE_0__xy__","TextBuffer","pos","toObject","val","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","test1","getOwnPropertyNames","test2","test3","forEach","letter","err","source","symbols","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","remaining","race","disable","enabled","onUnhandled","allRejections","matchWhitelist","rejections","error","whitelist","DEFAULT_WHITELIST","displayId","logged","logError","onHandled","warn","_72","line","list","some","cls","RangeError","normalizeName","test","normalizeValue","iteratorFor","items","iterator","support","iterable","Symbol","Headers","headers","append","isArray","header","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","bufferClone","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","rejected","decode","json","JSON","parse","normalizeMethod","upcased","methods","Request","input","url","credentials","mode","referrer","form","bytes","decodeURIComponent","parseHeaders","rawHeaders","Response","bodyInit","status","statusText","fetch","viewClasses","DataView","isView","oldValue","has","thisArg","entries","response","redirectStatuses","redirect","location","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"static/js/main.7de81c26.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dung/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 18);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__being__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__level__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__player__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__textbuffer__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__xy__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n\n\nvar Game = function () {\n\tfunction Game() {\n\t\t_classCallCheck(this, Game);\n\t}\n\n\t_createClass(Game, [{\n\t\tkey: 'init',\n\t\tvalue: function init() {\n\t\t\twindow.addEventListener(\"load\", this);\n\t\t}\n\t}, {\n\t\tkey: 'handleEvent',\n\t\tvalue: function handleEvent(e) {\n\t\t\tswitch (e.type) {\n\t\t\t\tcase \"load\":\n\t\t\t\t\twindow.removeEventListener(\"load\", this);\n\n\t\t\t\t\tthis.scheduler = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Scheduler.Speed();\n\t\t\t\t\tthis.engine = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Engine(this.scheduler);\n\t\t\t\t\tthis.display = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Display({ fontSize: 16 });\n\t\t\t\t\tthis.textBuffer = new __WEBPACK_IMPORTED_MODULE_5__textbuffer__[\"a\" /* default */](this.display);\n\t\t\t\t\tdocument.body.appendChild(this.display.getContainer());\n\t\t\t\t\tthis.player = new __WEBPACK_IMPORTED_MODULE_4__player__[\"a\" /* default */]();\n\n\t\t\t\t\t// FIXME build a level and position a player\n\t\t\t\t\tvar level = new __WEBPACK_IMPORTED_MODULE_3__level__[\"a\" /* default */]();\n\t\t\t\t\tvar size = level.getSize();\n\t\t\t\t\tthis._switchLevel(level);\n\t\t\t\t\tthis.level.setEntity(this.player, new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](Math.round(size.x / 2), Math.round(size.y / 2)));\n\n\t\t\t\t\tthis.engine.start();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'draw',\n\t\tvalue: function draw(xy) {\n\t\t\tvar entity = this.level.getEntityAt(xy);\n\t\t\tvar visual = entity.getVisual();\n\t\t\tthis.display.draw(xy.x, xy.y, visual.ch, visual.fg, visual.bg);\n\t\t}\n\t}, {\n\t\tkey: 'over',\n\t\tvalue: function over() {\n\t\t\tthis.engine.lock();\n\t\t\t// FIXME show something\n\t\t}\n\t}, {\n\t\tkey: '_switchLevel',\n\t\tvalue: function _switchLevel(level) {\n\t\t\t// remove old beings from the scheduler\n\t\t\tthis.scheduler.clear();\n\n\t\t\tthis.level = level;\n\t\t\tvar size = this.level.getSize();\n\n\t\t\tvar bufferSize = 3;\n\t\t\tthis.display.setOptions({ width: size.x, height: size.y + bufferSize });\n\t\t\tthis.textBuffer.configure({\n\t\t\t\tdisplay: this.display,\n\t\t\t\tposition: new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](0, size.y),\n\t\t\t\tsize: new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](size.x, bufferSize)\n\t\t\t});\n\t\t\tthis.textBuffer.clear();\n\n\t\t\t/* FIXME draw a level */\n\t\t\tvar xy = new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */]();\n\t\t\tfor (var i = 0; i < size.x; i++) {\n\t\t\t\txy.x = i;\n\t\t\t\tfor (var j = 0; j < size.y; j++) {\n\t\t\t\t\txy.y = j;\n\t\t\t\t\tthis.draw(xy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new beings to the scheduler\n\t\t\tvar beings = this.level.getBeings();\n\t\t\tfor (var p in beings) {\n\t\t\t\tthis.scheduler.add(beings[p], true);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Game;\n}();\n\nGame.scheduler = null;\nGame.engine = null;\nGame.player = null;\nGame.level = null;\nGame.display = null;\nGame.textBuffer = null;\n\n\nvar game = new Game();\n/* harmony default export */ __webpack_exports__[\"a\"] = (game);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XY = function () {\n\tfunction XY() {\n\t\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t_classCallCheck(this, XY);\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t_createClass(XY, [{\n\t\tkey: \"toString\",\n\t\tvalue: function toString() {\n\t\t\treturn this.x + \",\" + this.y;\n\t\t}\n\t}, {\n\t\tkey: \"is\",\n\t\tvalue: function is(xy) {\n\t\t\treturn this.x === xy.x && this.y === xy.y;\n\t\t}\n\t}, {\n\t\tkey: \"dist8\",\n\t\tvalue: function dist8(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\n\t\t}\n\t}, {\n\t\tkey: \"dist4\",\n\t\tvalue: function dist4(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.abs(dx) + Math.abs(dy);\n\t\t}\n\t}, {\n\t\tkey: \"dist\",\n\t\tvalue: function dist(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t}, {\n\t\tkey: \"plus\",\n\t\tvalue: function plus(xy) {\n\t\t\treturn new XY(this.x + xy.x, this.y + xy.y);\n\t\t}\n\t}, {\n\t\tkey: \"minus\",\n\t\tvalue: function minus(xy) {\n\t\t\treturn new XY(this.x - xy.x, this.y - xy.y);\n\t\t}\n\t}]);\n\n\treturn XY;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XY);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Entity = function () {\n\tfunction Entity(visual) {\n\t\t_classCallCheck(this, Entity);\n\n\t\tthis._visual = visual;\n\t\tthis._xy = null;\n\t\tthis._level = null;\n\t}\n\n\t_createClass(Entity, [{\n\t\tkey: \"getVisual\",\n\t\tvalue: function getVisual() {\n\t\t\treturn this._visual;\n\t\t}\n\t}, {\n\t\tkey: \"getXY\",\n\t\tvalue: function getXY() {\n\t\t\treturn this._xy;\n\t\t}\n\t}, {\n\t\tkey: \"getLevel\",\n\t\tvalue: function getLevel() {\n\t\t\treturn this._level;\n\t\t}\n\t}, {\n\t\tkey: \"setPosition\",\n\t\tvalue: function setPosition(xy, level) {\n\t\t\tthis._xy = xy;\n\t\t\tthis._level = level;\n\t\t\treturn this;\n\t\t}\n\t}]);\n\n\treturn Entity;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Entity);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(14)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(0);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar Being = function (_Entity) {\n\t_inherits(Being, _Entity);\n\n\tfunction Being(visual) {\n\t\t_classCallCheck(this, Being);\n\n\t\tvar _this = _possibleConstructorReturn(this, (Being.__proto__ || Object.getPrototypeOf(Being)).call(this, visual));\n\n\t\t_this.setPosition = function (xy, level) {\n\t\t\t// came to a currently active level; add self to the scheduler\n\t\t\tif (level !== this._level && level === __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level) {\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].scheduler.add(this, true);\n\t\t\t}\n\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */].prototype.setPosition.call(this, xy, level);\n\t\t};\n\n\t\t_this._speed = 100;\n\t\t_this._hp = 10;\n\t\treturn _this;\n\t}\n\n\t_createClass(Being, [{\n\t\tkey: 'getSpeed',\n\t\tvalue: function getSpeed() {\n\t\t\t// Called by the Scheduler\n\t\t\treturn this._speed;\n\t\t}\n\t}, {\n\t\tkey: 'damage',\n\t\tvalue: function damage(_damage) {\n\t\t\tthis._hp -= _damage;\n\t\t\tif (this._hp <= 0) {\n\t\t\t\tthis.die();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'act',\n\t\tvalue: function act() {\n\t\t\t/* FIXME */\n\t\t}\n\t}, {\n\t\tkey: 'die',\n\t\tvalue: function die() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].scheduler.remove(this);\n\t\t}\n\t}]);\n\n\treturn Being;\n}(__WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Being);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar asap = __webpack_require__(9);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  __webpack_require__(16).enable();\r\n  window.Promise = __webpack_require__(15);\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\n__webpack_require__(17);\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = __webpack_require__(13);\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(0);\n\n\n\nif (!__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.isSupported()) {\n    alert(\"The rot.js library isn't supported by your browser.\");\n} else {\n    // Initialize the game\n    __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].init();\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__xy__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar Level = function () {\n\tfunction Level() {\n\t\t_classCallCheck(this, Level);\n\n\t\t// FIXME data structure for storing entities\n\t\tthis._beings = {};\n\n\t\t// FIXME map data\n\t\tthis._size = new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](80, 25);\n\t\tthis._map = {};\n\n\t\tthis._empty = new __WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */]({ ch: \".\", fg: \"#888\", bg: null });\n\t}\n\n\t_createClass(Level, [{\n\t\tkey: 'getSize',\n\t\tvalue: function getSize() {\n\t\t\treturn this._size;\n\t\t}\n\t}, {\n\t\tkey: 'setEntity',\n\t\tvalue: function setEntity(entity, xy) {\n\t\t\t// FIXME remove from old position, draw\n\t\t\tif (entity.getLevel() === this) {\n\t\t\t\tvar oldXY = entity.getXY();\n\t\t\t\tdelete this._beings[oldXY];\n\t\t\t\tif (__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level === this) {\n\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].draw(oldXY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentity.setPosition(xy, this); // propagate position data to the entity itself\n\n\t\t\t// FIXME set new position, draw\n\t\t\tthis._beings[xy] = entity;\n\t\t\tif (__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level === this) {\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].draw(xy);\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].textBuffer.write(\"An entity moves to \" + xy + \".\");\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getEntityAt',\n\t\tvalue: function getEntityAt(xy) {\n\t\t\treturn this._beings[xy] || this._map[xy] || this._empty;\n\t\t}\n\t}, {\n\t\tkey: 'getBeings',\n\t\tvalue: function getBeings() {\n\t\t\t// FIXME list of all beings\n\t\t\treturn this._beings;\n\t\t}\n\t}]);\n\n\treturn Level;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Level);\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__being__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__game__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__xy__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar Player = function (_Being) {\n\t_inherits(Player, _Being);\n\n\tfunction Player() {\n\t\t_classCallCheck(this, Player);\n\n\t\tvar _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this, { ch: \"@\", fg: \"#fff\" }));\n\n\t\t_this._handleKey = function (code) {\n\t\t\tif (code in this._keys) {\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.clear();\n\n\t\t\t\tvar direction = this._keys[code];\n\t\t\t\tif (direction === -1) {\n\t\t\t\t\t// noop\n\t\t\t\t\t// FIXME show something?\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tvar dir = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.DIRS[8][direction];\n\t\t\t\tvar xy = this._xy.plus(new __WEBPACK_IMPORTED_MODULE_3__xy__[\"a\" /* default */](dir[0], dir[1]));\n\n\t\t\t\tthis._level.setEntity(this, xy); // FIXME collision detection\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false; // unknown key\n\t\t};\n\n\t\t_this._keys = {};\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_K] = 0;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_UP] = 0;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD8] = 0;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_U] = 1;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD9] = 1;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_L] = 2;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RIGHT] = 2;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD6] = 2;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_N] = 3;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD3] = 3;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_J] = 4;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_DOWN] = 4;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD2] = 4;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_B] = 5;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD1] = 5;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_H] = 6;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_LEFT] = 6;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD4] = 6;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_Y] = 7;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD7] = 7;\n\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PERIOD] = -1;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_CLEAR] = -1;\n\t\t_this._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD5] = -1;\n\t\treturn _this;\n\t}\n\n\t_createClass(Player, [{\n\t\tkey: 'act',\n\t\tvalue: function act() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.write(\"It is your turn, press any relevant key.\");\n\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.flush();\n\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].engine.lock();\n\t\t\twindow.addEventListener(\"keydown\", this);\n\t\t}\n\t}, {\n\t\tkey: 'die',\n\t\tvalue: function die() {\n\t\t\t_get(Player.prototype.__proto__ || Object.getPrototypeOf(Player.prototype), 'die', this).call(this);\n\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].over();\n\t\t}\n\t}, {\n\t\tkey: 'handleEvent',\n\t\tvalue: function handleEvent(e) {\n\t\t\tvar code = e.keyCode;\n\n\t\t\tvar keyHandled = this._handleKey(e.keyCode);\n\n\t\t\tif (keyHandled) {\n\t\t\t\twindow.removeEventListener(\"keydown\", this);\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].engine.unlock();\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Player;\n}(__WEBPACK_IMPORTED_MODULE_1__being__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Player);\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__xy__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar TextBuffer = function () {\n\tfunction TextBuffer() {\n\t\t_classCallCheck(this, TextBuffer);\n\n\t\tthis._data = [];\n\t\tthis._options = {\n\t\t\tdisplay: null,\n\t\t\tposition: new __WEBPACK_IMPORTED_MODULE_0__xy__[\"a\" /* default */](),\n\t\t\tsize: new __WEBPACK_IMPORTED_MODULE_0__xy__[\"a\" /* default */]()\n\t\t};\n\t}\n\n\t_createClass(TextBuffer, [{\n\t\tkey: \"configure\",\n\t\tvalue: function configure(options) {\n\t\t\tfor (var p in options) {\n\t\t\t\tthis._options[p] = options[p];\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"clear\",\n\t\tvalue: function clear() {\n\t\t\tthis._data = [];\n\t\t}\n\t}, {\n\t\tkey: \"write\",\n\t\tvalue: function write(text) {\n\t\t\tthis._data.push(text);\n\t\t}\n\t}, {\n\t\tkey: \"flush\",\n\t\tvalue: function flush() {\n\t\t\tvar options = this._options;\n\t\t\tvar display = options.display;\n\t\t\tvar pos = options.position;\n\t\t\tvar size = options.size;\n\n\t\t\t// clear\n\t\t\tfor (var i = 0; i < size.x; i++) {\n\t\t\t\tfor (var j = 0; j < size.y; j++) {\n\t\t\t\t\tdisplay.draw(pos.x + i, pos.y + j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar text = this._data.join(\" \");\n\t\t\tdisplay.drawText(pos.x, pos.y, text, size.x);\n\t\t}\n\t}]);\n\n\treturn TextBuffer;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TextBuffer);\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(5);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(5);\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(7);\nmodule.exports = __webpack_require__(8);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// static/js/main.7de81c26.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dung/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e4e52588555cb83c4ac2","import ROT from 'rot-js'\r\nimport Being from './being'\r\nimport Entity from './entity'\r\nimport Level from './level'\r\nimport Player from './player'\r\nimport TextBuffer from './textbuffer'\r\nimport XY from './xy'\r\n\r\nclass Game {\r\n\tstatic scheduler = null\r\n\tstatic engine = null\r\n\tstatic player = null\r\n\tstatic level = null\r\n\tstatic display = null\r\n\tstatic textBuffer = null\r\n\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\t\twindow.addEventListener(\"load\", this);\r\n\t}\r\n\r\n\thandleEvent(e) {\r\n\t\tswitch (e.type) {\r\n\t\t\tcase \"load\":\r\n\t\t\t\twindow.removeEventListener(\"load\", this);\r\n\r\n\t\t\t\tthis.scheduler = new ROT.Scheduler.Speed();\r\n\t\t\t\tthis.engine = new ROT.Engine(this.scheduler);\r\n\t\t\t\tthis.display = new ROT.Display({fontSize:16});\r\n\t\t\t\tthis.textBuffer = new TextBuffer(this.display);\r\n\t\t\t\tdocument.body.appendChild(this.display.getContainer());\r\n\t\t\t\tthis.player = new Player();\r\n\r\n\t\t\t\t// FIXME build a level and position a player\r\n\t\t\t\tconst level = new Level();\r\n\t\t\t\tconst size = level.getSize();\r\n\t\t\t\tthis._switchLevel(level);\r\n\t\t\t\tthis.level.setEntity(this.player, new XY(Math.round(size.x/2), Math.round(size.y/2)));\r\n\r\n\t\t\t\tthis.engine.start();\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tdraw(xy) {\r\n\t\tconst entity = this.level.getEntityAt(xy);\r\n\t\tconst visual = entity.getVisual();\r\n\t\tthis.display.draw(xy.x, xy.y, visual.ch, visual.fg, visual.bg);\r\n\t}\r\n\r\n\tover() {\r\n\t\tthis.engine.lock();\r\n\t\t// FIXME show something\r\n\t}\r\n\r\n\t_switchLevel(level) {\r\n\t\t// remove old beings from the scheduler\r\n\t\tthis.scheduler.clear();\r\n\r\n\t\tthis.level = level;\r\n\t\tconst size = this.level.getSize();\r\n\r\n\t\tconst bufferSize = 3;\r\n\t\tthis.display.setOptions({width:size.x, height:size.y + bufferSize});\r\n\t\tthis.textBuffer.configure({\r\n\t\t\tdisplay: this.display,\r\n\t\t\tposition: new XY(0, size.y),\r\n\t\t\tsize: new XY(size.x, bufferSize)\r\n\t\t});\r\n\t\tthis.textBuffer.clear();\r\n\r\n\t\t/* FIXME draw a level */\r\n\t\tconst xy = new XY();\r\n\t\tfor (let i = 0; i < size.x; i++) {\r\n\t\t\txy.x = i;\r\n\t\t\tfor (let j = 0; j < size.y; j++) {\r\n\t\t\t\txy.y = j;\r\n\t\t\t\tthis.draw(xy);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// add new beings to the scheduler\r\n\t\tconst beings = this.level.getBeings();\r\n\t\tfor (let p in beings) {\r\n\t\t\tthis.scheduler.add(beings[p], true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst game = new Game();\r\nexport default game;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","export default class XY {\r\n\tconstructor(x = 0, y = 0) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\ttoString() {\r\n\t\treturn this.x + \",\" + this.y;\r\n\t}\r\n\tis(xy) {\r\n\t\treturn (this.x === xy.x && this.y === xy.y);\r\n\t}\r\n\tdist8(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\r\n\t}\r\n\tdist4(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.abs(dx) + Math.abs(dy);\r\n\t}\r\n\tdist(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.sqrt(dx*dx+dy*dy);\r\n\t}\r\n\tplus(xy) {\r\n\t\treturn new XY(this.x+xy.x, this.y+xy.y);\r\n\t}\r\n\tminus(xy) {\r\n\t\treturn new XY(this.x-xy.x, this.y-xy.y);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/xy.js","export default class Entity {\r\n\tconstructor(visual) {\r\n\t\tthis._visual = visual;\r\n\t\tthis._xy = null;\r\n\t\tthis._level = null;\r\n\t}\r\n\tgetVisual() {\r\n\t\treturn this._visual;\r\n\t}\r\n\tgetXY() {\r\n\t\treturn this._xy;\r\n\t}\r\n\tgetLevel() {\r\n\t\treturn this._level;\r\n\t}\r\n\tsetPosition(xy, level) {\r\n\t\tthis._xy = xy;\r\n\t\tthis._level = level;\r\n\t\treturn this;\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entity.js","/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rot-js/lib/rot.js\n// module id = 3\n// module chunks = 0","import Entity from './entity'\r\nimport Game from './game'\r\n\r\nexport default class Being extends Entity {\r\n\tconstructor(visual) {\r\n\t\tsuper(visual);\r\n\t\tthis._speed = 100;\r\n\t\tthis._hp = 10;\r\n\t}\r\n\tgetSpeed() {\r\n\t\t// Called by the Scheduler\r\n\t\treturn this._speed;\r\n\t}\r\n\tdamage(damage) {\r\n\t\tthis._hp -= damage;\r\n\t\tif (this._hp <= 0) { this.die(); }\r\n\t}\r\n\tact() {\r\n\t\t/* FIXME */\r\n\t}\r\n\tdie() {\r\n\t\tGame.scheduler.remove(this);\r\n\t}\r\n\tsetPosition = function(xy, level) {\r\n\t\t// came to a currently active level; add self to the scheduler\r\n\t\tif (level !== this._level && level === Game.level) {\r\n\t\t\tGame.scheduler.add(this, true);\r\n\t\t}\r\n\r\n\t\treturn Entity.prototype.setPosition.call(this, xy, level);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/being.js","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0","'use strict';\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  require('promise/lib/rejection-tracking').enable();\r\n  window.Promise = require('promise/lib/es6-extensions.js');\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\nrequire('whatwg-fetch');\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = require('object-assign');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./config/polyfills.js\n// module id = 7\n// module chunks = 0","import ROT from 'rot-js'\r\nimport game from './game';\r\n\r\nif (!ROT.isSupported()) {\r\n    alert(\"The rot.js library isn't supported by your browser.\");\r\n} else {\r\n    // Initialize the game\r\n    game.init();\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 9\n// module chunks = 0","import Entity from './entity'\r\nimport Game from './game'\r\nimport XY from './xy'\r\n\r\nexport default class Level {\r\n\tconstructor() {\r\n\t\t// FIXME data structure for storing entities\r\n\t\tthis._beings = {};\r\n\r\n\t\t// FIXME map data\r\n\t\tthis._size = new XY(80, 25);\r\n\t\tthis._map = {};\r\n\r\n\t\tthis._empty = new Entity({ch:\".\", fg:\"#888\", bg:null});\r\n\t}\r\n\tgetSize() {\r\n\t\treturn this._size;\r\n\t}\r\n\tsetEntity(entity, xy) {\r\n\t\t// FIXME remove from old position, draw\r\n\t\tif (entity.getLevel() === this) {\r\n\t\t\tvar oldXY = entity.getXY();\r\n\t\t\tdelete this._beings[oldXY];\r\n\t\t\tif (Game.level === this) { Game.draw(oldXY); }\r\n\t\t}\r\n\r\n\t\tentity.setPosition(xy, this); // propagate position data to the entity itself\r\n\r\n\t\t// FIXME set new position, draw\r\n\t\tthis._beings[xy] = entity;\r\n\t\tif (Game.level === this) {\r\n\t\t\tGame.draw(xy);\r\n\t\t\tGame.textBuffer.write(\"An entity moves to \" + xy + \".\");\r\n\t\t}\r\n\t}\r\n\tgetEntityAt(xy) {\r\n\t\treturn this._beings[xy] || this._map[xy] || this._empty;\r\n\t}\r\n\tgetBeings() {\r\n\t\t// FIXME list of all beings\r\n\t\treturn this._beings;\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/level.js","import ROT from 'rot-js'\r\nimport Being from './being'\r\nimport Game from './game'\r\nimport XY from './xy'\r\n\r\nexport default class Player extends Being{\n\tconstructor() {\n\t\tsuper({ch:\"@\", fg:\"#fff\"});\n\n\t\tthis._keys = {};\r\n\t\tthis._keys[ROT.VK_K] = 0;\r\n\t\tthis._keys[ROT.VK_UP] = 0;\r\n\t\tthis._keys[ROT.VK_NUMPAD8] = 0;\r\n\t\tthis._keys[ROT.VK_U] = 1;\r\n\t\tthis._keys[ROT.VK_NUMPAD9] = 1;\r\n\t\tthis._keys[ROT.VK_L] = 2;\r\n\t\tthis._keys[ROT.VK_RIGHT] = 2;\r\n\t\tthis._keys[ROT.VK_NUMPAD6] = 2;\r\n\t\tthis._keys[ROT.VK_N] = 3;\r\n\t\tthis._keys[ROT.VK_NUMPAD3] = 3;\r\n\t\tthis._keys[ROT.VK_J] = 4;\r\n\t\tthis._keys[ROT.VK_DOWN] = 4;\r\n\t\tthis._keys[ROT.VK_NUMPAD2] = 4;\r\n\t\tthis._keys[ROT.VK_B] = 5;\r\n\t\tthis._keys[ROT.VK_NUMPAD1] = 5;\r\n\t\tthis._keys[ROT.VK_H] = 6;\r\n\t\tthis._keys[ROT.VK_LEFT] = 6;\r\n\t\tthis._keys[ROT.VK_NUMPAD4] = 6;\r\n\t\tthis._keys[ROT.VK_Y] = 7;\r\n\t\tthis._keys[ROT.VK_NUMPAD7] = 7;\r\n\r\n\t\tthis._keys[ROT.VK_PERIOD] = -1;\r\n\t\tthis._keys[ROT.VK_CLEAR] = -1;\r\n\t\tthis._keys[ROT.VK_NUMPAD5] = -1;\n\t}\n\tact() {\r\n\t\tGame.textBuffer.write(\"It is your turn, press any relevant key.\");\r\n\t\tGame.textBuffer.flush();\r\n\t\tGame.engine.lock();\r\n\t\twindow.addEventListener(\"keydown\", this);\r\n\t}\n\tdie() {\r\n\t\tsuper.die();\r\n\t\tGame.over();\r\n\t}\n\thandleEvent(e) {\r\n\t\tconst code = e.keyCode;\r\n\r\n\t\tconst keyHandled = this._handleKey(e.keyCode);\r\n\r\n\t\tif (keyHandled) {\r\n\t\t\twindow.removeEventListener(\"keydown\", this);\r\n\t\t\tGame.engine.unlock();\r\n\t\t}\r\n\t}\n\t_handleKey = function(code) {\r\n\t\tif (code in this._keys) {\r\n\t\t\tGame.textBuffer.clear();\r\n\r\n\t\t\tconst direction = this._keys[code];\r\n\t\t\tif (direction === -1) { // noop\r\n\t\t\t\t// FIXME show something?\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tconst dir = ROT.DIRS[8][direction];\r\n\t\t\tconst xy = this._xy.plus(new XY(dir[0], dir[1]));\r\n\r\n\t\t\tthis._level.setEntity(this, xy); // FIXME collision detection\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false; // unknown key\r\n\t}\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/player.js","import XY from './xy'\r\n\r\nexport default class TextBuffer {\r\n\tconstructor() {\r\n\t\tthis._data = [];\r\n\t\tthis._options = {\r\n\t\t\tdisplay: null,\r\n\t\t\tposition: new XY(),\r\n\t\t\tsize: new XY()\r\n\t\t}\r\n\t}\r\n\tconfigure(options) {\r\n\t\tfor (var p in options) { this._options[p] = options[p]; }\r\n\t}\r\n\tclear() {\r\n\t\tthis._data = [];\r\n\t}\r\n\twrite(text) {\r\n\t\tthis._data.push(text);\r\n\t}\r\n\tflush() {\r\n\t\tconst options = this._options;\r\n\t\tconst display = options.display;\r\n\t\tconst pos = options.position;\r\n\t\tconst size = options.size;\r\n\r\n\t\t// clear\r\n\t\tfor (let i = 0; i < size.x; i++) {\r\n\t\t\tfor (let j = 0; j < size.y; j++) {\r\n\t\t\t\tdisplay.draw(pos.x + i, pos.y + j);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar text = this._data.join(\" \");\r\n\t\tdisplay.drawText(pos.x, pos.y, text, size.x);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/textbuffer.js","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 13\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 14\n// module chunks = 0","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/rejection-tracking.js\n// module id = 16\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}