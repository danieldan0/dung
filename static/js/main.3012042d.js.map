{"version":3,"sources":["..\\static\\js\\main.3012042d.js","..\\webpack\\bootstrap cd1298cf87e8c9a65c0c","..\\node_modules\\rot-js\\lib\\rot.js","const.js","game.js","xy.js","entities.js","entity.js","glyph.js","tile.js","..\\node_modules\\promise\\lib\\core.js","..\\node_modules\\webpack\\buildin\\global.js","..\\config\\polyfills.js","index.js","..\\node_modules\\asap\\browser-raw.js","map.js","mapgen.js","mixins.js","screens.js","..\\node_modules\\object-assign\\index.js","..\\node_modules\\process\\browser.js","..\\node_modules\\promise\\lib\\es6-extensions.js","..\\node_modules\\promise\\lib\\rejection-tracking.js","..\\node_modules\\whatwg-fetch\\fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","process","requestAnimationFrame","cb","setTimeout","document","body","appendChild","child","scrollLeft","scrollTop","createElement","type","canvas","getBoundingClientRect","left","top","getContext","_termcolor","beginPath","clearRect","x","y","w","h","this","clearCmd","clearToAnsi","fillStyle","stdout","write","drawImage","a","b","e","f","g","fill","fillRect","fillText","chs","font","lineTo","measureText","ch","width","moveTo","textAlign","textBaseline","height","style","position","visibility","documentElement","ROT","isSupported","Function","bind","DEFAULT_WIDTH","DEFAULT_HEIGHT","DIRS","4","8","6","VK_CANCEL","VK_HELP","VK_BACK_SPACE","VK_TAB","VK_CLEAR","VK_RETURN","VK_ENTER","VK_SHIFT","VK_CONTROL","VK_ALT","VK_PAUSE","VK_CAPS_LOCK","VK_ESCAPE","VK_SPACE","VK_PAGE_UP","VK_PAGE_DOWN","VK_END","VK_HOME","VK_LEFT","VK_UP","VK_RIGHT","VK_DOWN","VK_PRINTSCREEN","VK_INSERT","VK_DELETE","VK_0","VK_1","VK_2","VK_3","VK_4","VK_5","VK_6","VK_7","VK_8","VK_9","VK_COLON","VK_SEMICOLON","VK_LESS_THAN","VK_EQUALS","VK_GREATER_THAN","VK_QUESTION_MARK","VK_AT","VK_A","VK_B","VK_C","VK_D","VK_E","VK_F","VK_G","VK_H","VK_I","VK_J","VK_K","VK_L","VK_M","VK_N","VK_O","VK_P","VK_Q","VK_R","VK_S","VK_T","VK_U","VK_V","VK_W","VK_X","VK_Y","VK_Z","VK_CONTEXT_MENU","VK_NUMPAD0","VK_NUMPAD1","VK_NUMPAD2","VK_NUMPAD3","VK_NUMPAD4","VK_NUMPAD5","VK_NUMPAD6","VK_NUMPAD7","VK_NUMPAD8","VK_NUMPAD9","VK_MULTIPLY","VK_ADD","VK_SEPARATOR","VK_SUBTRACT","VK_DECIMAL","VK_DIVIDE","VK_F1","VK_F2","VK_F3","VK_F4","VK_F5","VK_F6","VK_F7","VK_F8","VK_F9","VK_F10","VK_F11","VK_F12","VK_F13","VK_F14","VK_F15","VK_F16","VK_F17","VK_F18","VK_F19","VK_F20","VK_F21","VK_F22","VK_F23","VK_F24","VK_NUM_LOCK","VK_SCROLL_LOCK","VK_CIRCUMFLEX","VK_EXCLAMATION","VK_DOUBLE_QUOTE","VK_HASH","VK_DOLLAR","VK_PERCENT","VK_AMPERSAND","VK_UNDERSCORE","VK_OPEN_PAREN","VK_CLOSE_PAREN","VK_ASTERISK","VK_PLUS","VK_PIPE","VK_HYPHEN_MINUS","VK_OPEN_CURLY_BRACKET","VK_CLOSE_CURLY_BRACKET","VK_TILDE","VK_COMMA","VK_PERIOD","VK_SLASH","VK_BACK_QUOTE","VK_OPEN_BRACKET","VK_BACK_SLASH","VK_CLOSE_BRACKET","VK_QUOTE","VK_META","VK_ALTGR","VK_WIN","VK_KANA","VK_HANGUL","VK_EISU","VK_JUNJA","VK_FINAL","VK_HANJA","VK_KANJI","VK_CONVERT","VK_NONCONVERT","VK_ACCEPT","VK_MODECHANGE","VK_SELECT","VK_PRINT","VK_EXECUTE","VK_SLEEP","Text","RE_COLORS","TYPE_TEXT","TYPE_NEWLINE","TYPE_FG","TYPE_BG","measure","str","maxWidth","result","tokens","tokenize","lineWidth","length","token","Math","max","offset","replace","match","index","part","substring","push","trim","_breakLines","Infinity","lineLength","lastTokenWithSpace","charAt","indexOf","_breakInsideToken","arr","split","pop","join","nextIndex","breakIndex","lastIndexOf","splice","lastTextToken","tokenIndex","removeBreakChar","newBreakToken","newTextToken","Array","random","floor","RNG","getUniform","randomize","Number","mod","String","capitalize","toUpperCase","lpad","character","count","cnt","rpad","format","template","map","args","slice","arguments","replacer","group1","group2","obj","group","parts","shift","method","toLowerCase","replaced","apply","first","unshift","create","tmp","extend","parent","constructor","window","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","Display","options","_context","_data","_dirty","_options","_backend","defaultOptions","transpose","layout","fontSize","spacing","border","forceSquareRatio","fontFamily","fontStyle","fg","bg","tileWidth","tileHeight","tileMap","tileSet","tileColorize","termColor","setOptions","DEBUG","_tick","what","colors","draw","clear","compute","getOptions","getContainer","computeSize","availWidth","availHeight","computeFontSize","eventToPosition","touches","clientX","clientY","rect","drawText","text","cx","cy","lines","isSpace","isPrevSpace","isFullWidth","isPrevFullWidth","cc","charCodeAt","_draw","key","clearBefore","data","Backend","context","Rect","_spacingX","_spacingY","_canvasCache","cache","charWidth","ceil","_drawWithCache","_drawNoCache","hash","ctx","chars","concat","boxWidth","boxHeight","oldFont","ratio","widthFraction","Hex","_hexSize","sqrt","xprop","yprop","px","reverse","_fill","hexSizeWidth","hexSizeHeight","hexSize","min","prop","size","Tile","_colorCanvas","tile","Error","globalCompositeOperation","getSeed","_seed","setSeed","seed","_s0","_frac","_s1","_s2","_c","t","getUniformInt","lowerBound","upperBound","getNormal","mean","stddev","u","v","r","gauss","log","getPercentage","getWeightedValue","total","getState","setState","state","clone","Date","now","StringGenerator","words","order","prior","_boundary","fromCharCode","_suffix","_prefix","_priorValues","generate","_sample","_join","observe","string","_split","event","j","subcontext","_observeEvent","getStats","priorCount","dataCount","eventCount","_backoff","available","EventQueue","_time","_events","_eventTimes","getTime","add","time","remove","_remove","Scheduler","_queue","_repeat","_current","item","repeat","next","Simple","Speed","getSpeed","Action","_defaultDuration","_duration","setDuration","Engine","scheduler","_scheduler","_lock","start","unlock","lock","actor","act","then","Map","_width","_height","callback","_fillMap","Arena","empty","DividedMaze","_stack","_map","_process","room","_partitionRoom","availX","availY","bottom","right","walls","solid","hole","IceyMaze","regularity","_regularity","nx","ny","done","blocked","dirs","_randomize","_isFree","EllerMaze","L","R","_addToList","_removeFromList","Cellular","born","survive","topology","connected","_dirs","probability","set","newMap","widthStep","widthStart","cur","ncount","_getNeighbors","_completeMaze","dir","allFreeSpace","notConnected","_freeSpace","_pointKey","_findConnected","keys","_getFromTo","from","to","local","_tunnelToConnected","k","pp","connectedKeys","notConnectedKeys","_getClosest","point","space","minPoint","minDist","stack","keepNotConnected","tests","xx","pkey","yy","Dungeon","_rooms","_corridors","getRooms","getCorridors","Digger","roomWidth","roomHeight","corridorLength","dugPercentage","timeLimit","_features","Room","Corridor","_featureAttempts","_walls","_digCallback","_canBeDugCallback","_isWallCallback","_priorityWallCallback","_dug","area","_firstRoom","t1","wall","_findWall","parseInt","_getDiggingDirection","featureAttempts","_tryFeature","_removeSurroundingWalls","priorityWalls","_addDoors","Feature","createRandomCenter","prio1","prio2","dx","dy","feature","createRandomAt","isValid","createPriorityWalls","deltas","delta","isWallCallback","clearDoors","addDoors","Uniform","roomDugPercentage","_roomAttempts","_corridorAttempts","_connected","_unconnected","_generateRooms","_generateCorridors","_generateRoom","createRandom","room1","_closestRoom","room2","_connectRooms","rooms","dist","center","getCenter","center1","center2","diffX","diffY","abs","dirIndex1","dirIndex2","getLeft","getRight","getTop","getBottom","_placeInWall","end","_digLine","diff","rotation","mid","index2","round","mid1","mid2","addDoor","dirIndex","avail","lastBadIndex","points","corridor","Rogue","cellWidth","cellHeight","_calculateRoomSize","connectedCells","_initRooms","_connectUnconnectedRooms","_createRandomRoomConnections","_createRooms","_createCorridors","cell","connections","cellx","celly","idx","ncgx","ncgy","otherRoom","cgx","cgy","found","dirToCheck","cw","validRoom","directions","dirIdx","newI","newJ","console","roomw","roomh","sx","sy","cwp","chp","sxOffset","syOffset","ii","jj","_getWallPosition","aRoom","aDirection","rx","ry","door","_drawCorridore","startPosition","endPosition","tempDist","xDir","yDir","move","xOffset","yOffset","xpos","ypos","moves","xAbs","yAbs","percent","firstHalf","secondHalf","connection","otherWall","canBeDugCallback","digCallback","debug","x1","y1","x2","y2","doorX","doorY","_x1","_y1","_x2","_y2","_doors","getDoors","startX","startY","endX","endY","_startX","_startY","_endX","_endY","_endsWithAWall","ok","firstCornerBad","secondCornerBad","priorityWallCallback","Noise","Simplex","gradients","_F2","_G2","_gradients","permutations","_perms","_indexes","xin","yin","gi","i1","j1","perms","indexes","G2","n0","n1","n2","X0","Y0","x0","y0","t0","grad","t2","FOV","lightPassesCallback","_lightPasses","_getCircle","countFactor","startOffset","DiscreteShadowcasting","_coords","A","B","blocks","DATA","neighbors","angle","_visibleCoords","v1","callee","v2","PreciseShadowcasting","A1","A2","SHADOWS","neighborCount","_checkVisibility","index1","edge1","old","edge2","visible","visibleLength","P","P1","P2","RecursiveShadowcasting","OCTANTS","_renderOctant","compute180","previousOctant","nextPreviousOctant","nextOctant","compute90","octant","_castVisibility","row","visSlopeStart","visSlopeEnd","radius","xy","yx","newStart","mapX","mapY","slopeStart","slopeEnd","Color","fromString","cached","_cache","values","color1","color2","add_","multiply","multiply_","interpolate","factor","interpolateHSL","hsl1","rgb2hsl","hsl2","hsl2rgb","color","hue2rgb","q","toRGB","_clamp","toHex","toString","num","black","navy","darkblue","mediumblue","blue","darkgreen","green","teal","darkcyan","deepskyblue","darkturquoise","mediumspringgreen","lime","springgreen","aqua","cyan","midnightblue","dodgerblue","forestgreen","seagreen","darkslategray","darkslategrey","limegreen","mediumseagreen","turquoise","royalblue","steelblue","darkslateblue","mediumturquoise","indigo","darkolivegreen","cadetblue","cornflowerblue","mediumaquamarine","dimgray","dimgrey","slateblue","olivedrab","slategray","slategrey","lightslategray","lightslategrey","mediumslateblue","lawngreen","chartreuse","aquamarine","maroon","purple","olive","gray","grey","skyblue","lightskyblue","blueviolet","darkred","darkmagenta","saddlebrown","darkseagreen","lightgreen","mediumpurple","darkviolet","palegreen","darkorchid","yellowgreen","sienna","brown","darkgray","darkgrey","lightblue","greenyellow","paleturquoise","lightsteelblue","powderblue","firebrick","darkgoldenrod","mediumorchid","rosybrown","darkkhaki","silver","mediumvioletred","indianred","peru","chocolate","tan","lightgray","lightgrey","palevioletred","thistle","orchid","goldenrod","crimson","gainsboro","plum","burlywood","lightcyan","lavender","darksalmon","violet","palegoldenrod","lightcoral","khaki","aliceblue","honeydew","azure","sandybrown","wheat","beige","whitesmoke","mintcream","ghostwhite","salmon","antiquewhite","linen","lightgoldenrodyellow","oldlace","red","fuchsia","magenta","deeppink","orangered","tomato","hotpink","coral","darkorange","lightsalmon","orange","lightpink","pink","gold","peachpuff","navajowhite","moccasin","bisque","mistyrose","blanchedalmond","papayawhip","lavenderblush","seashell","cornsilk","lemonchiffon","floralwhite","snow","yellow","lightyellow","ivory","white","Lighting","reflectivityCallback","_reflectivityCallback","passes","emissionThreshold","range","_fov","_lights","_reflectivityCache","_fovCache","reset","setFOV","fov","setLight","clearLights","lightingCallback","doneCells","emittingCells","litCells","light","_emitLight","_computeEmitters","litKey","_emitLightFromCell","reflectivity","emission","intensity","_updateFOV","fovKey","formFactor","key1","vis","key2","Path","toX","toY","passableCallback","_toX","_toY","_fromX","_fromY","_passableCallback","fromX","fromY","Dijkstra","_computed","_todo","_add","_compute","prev","neighbor","AStar","_done","_distance","Term","_cx","_cy","_lastColor","_ox","_oy","columns","rows","positionToAnsi","newColor","colorToAnsi","Xterm","rgb","__webpack_exports__","DisplayOptions","MapOptions","Tiles","null","chr","foreground","background","isWalkable","isDiggable","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_rot_js__","__WEBPACK_IMPORTED_MODULE_0_rot_js___default","__WEBPACK_IMPORTED_MODULE_1__screens__","__WEBPACK_IMPORTED_MODULE_2__const__","_createClass","defineProperties","target","props","descriptor","writable","protoProps","staticProps","Game","currentScreen","_this","display","addEventListener","handleInput","switchScreen","startScreen","screen","exit","enter","refresh","render","game","XY","undefined","PlayerTemplate","FungusTemplate","EnemyTemplate","__WEBPACK_IMPORTED_MODULE_0__mixins__","mixins","Moveable","PlayerActor","FungusActor","EnemyActor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__glyph__","_typeof","Symbol","iterator","Entity","_Glyph","properties","getPrototypeOf","attachedMixins","attachedMixinGroups","groupName","init","Glyph","__WEBPACK_IMPORTED_MODULE_1__const__","noop","getThen","ex","LAST_ERROR","IS_ERROR","tryCallOne","fn","tryCallTwo","Promise","_45","_81","_65","_54","doResolve","safeThen","onFulfilled","onRejected","resolve","reject","res","handle","Handler","deferred","_10","handleResolved","asap","promise","ret","newValue","finale","_97","reason","_61","eval","enable","assign","__WEBPACK_IMPORTED_MODULE_1__game__","alert","rawAsap","task","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromTimer","handleTimer","timeoutHandle","clearInterval","intervalHandle","setInterval","scope","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","toggle","observer","node","createTextNode","characterData","__WEBPACK_IMPORTED_MODULE_1__tile__","__WEBPACK_IMPORTED_MODULE_2__xy__","__WEBPACK_IMPORTED_MODULE_3__entity__","__WEBPACK_IMPORTED_MODULE_4__entities__","tiles","player","entities","engine","addEntityAtRandomPosition","isInBounds","getTile","getEntityAt","is","entity","hasMixin","getRandomFloorTile","addEntity","GenerateMap","__WEBPACK_IMPORTED_MODULE_3__tile__","__WEBPACK_IMPORTED_MODULE_1__map__","__WEBPACK_IMPORTED_MODULE_1__xy__","__WEBPACK_IMPORTED_MODULE_2__game__","Mixins","tryMove","dig","astar","path","pathCallback","Teleportable","teleport","__WEBPACK_IMPORTED_MODULE_2__mapgen__","__WEBPACK_IMPORTED_MODULE_3__const__","__WEBPACK_IMPORTED_MODULE_4__xy__","__WEBPACK_IMPORTED_MODULE_5__entity__","__WEBPACK_IMPORTED_MODULE_6__entities__","Screen","inputType","inputData","keyCode","playScreen","distance","newXY","plus","screenWidth","screenHeight","topLeftX","topLeftY","winScreen","loseScreen","direction","toObject","val","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","test1","getOwnPropertyNames","test2","test3","forEach","letter","err","source","symbols","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","remaining","race","disable","enabled","onUnhandled","allRejections","matchWhitelist","rejections","error","whitelist","DEFAULT_WHITELIST","displayId","logged","logError","onHandled","warn","_72","line","list","some","cls","RangeError","normalizeName","test","normalizeValue","iteratorFor","items","support","iterable","Headers","headers","append","isArray","header","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","bufferClone","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","rejected","decode","json","JSON","parse","normalizeMethod","upcased","methods","Request","input","url","credentials","mode","referrer","form","bytes","decodeURIComponent","parseHeaders","rawHeaders","Response","bodyInit","status","statusText","fetch","viewClasses","DataView","isView","oldValue","has","thisArg","entries","response","redirectStatuses","redirect","location","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"static/js/main.3012042d.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dung/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(18)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DisplayOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MapOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return Tiles; });\nvar DisplayOptions = {\n    width: 80,\n    height: 25\n};\n\nvar MapOptions = {\n    width: 80,\n    height: 25\n};\n\nvar Tiles = {\n    \"null\": {},\n    floor: {\n        chr: \".\",\n        foreground: \"#444\",\n        background: \"#222\",\n        isWalkable: true\n    },\n    wall: {\n        chr: \"#\",\n        foreground: \"#777\",\n        background: \"#2e2e2e\",\n        isDiggable: true\n    }\n};\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__screens__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__const__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar Game = function () {\n    function Game() {\n        _classCallCheck(this, Game);\n\n        this.currentScreen = null;\n    }\n\n    _createClass(Game, [{\n        key: 'init',\n        value: function init() {\n            var _this = this;\n\n            // Initialize display\n            this.display = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Display(__WEBPACK_IMPORTED_MODULE_2__const__[\"a\" /* DisplayOptions */]);\n            // Append display to the document (HTML file)\n            // This creates an <canvas> in the document\n            document.body.appendChild(this.display.getContainer());\n            // Helper function\n            var bindEventToScreen = function bindEventToScreen(event) {\n                window.addEventListener(event, function (e) {\n                    // When an event is received, send it to the\n                    // screen if there is one\n                    if (_this.currentScreen !== null) {\n                        // Send the event type and data to the screen\n                        _this.currentScreen.handleInput(event, e);\n                    }\n                });\n            };\n            // Bind keyboard input events\n            bindEventToScreen('keydown');\n            // bindEventToScreen('keyup');\n            // bindEventToScreen('keypress');\n            this.switchScreen(__WEBPACK_IMPORTED_MODULE_1__screens__[\"a\" /* default */].startScreen);\n        }\n    }, {\n        key: 'switchScreen',\n        value: function switchScreen(screen) {\n            // If we had a screen before, notify it that we exited\n            if (this.currentScreen !== null) {\n                this.currentScreen.exit();\n            }\n            // Clear the display\n            this.display.clear();\n            // Update our current screen, notify it we entered\n            // and then render it\n            this.currentScreen = screen;\n            if (this.currentScreen) {\n                this.currentScreen.enter();\n                this.refresh();\n            }\n        }\n    }, {\n        key: 'refresh',\n        value: function refresh() {\n            // Clear the screen\n            this.display.clear();\n            // Render the screen\n            this.currentScreen.render(this.display);\n        }\n    }]);\n\n    return Game;\n}();\n\nvar game = new Game();\n/* harmony default export */ __webpack_exports__[\"a\"] = (game);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XY = function () {\n\tfunction XY() {\n\t\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t_classCallCheck(this, XY);\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t_createClass(XY, [{\n\t\tkey: \"toString\",\n\t\tvalue: function toString() {\n\t\t\treturn this.x + \",\" + this.y;\n\t\t}\n\t}, {\n\t\tkey: \"is\",\n\t\tvalue: function is(xy) {\n\t\t\treturn this.x === xy.x && this.y === xy.y;\n\t\t}\n\t}, {\n\t\tkey: \"dist8\",\n\t\tvalue: function dist8(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\n\t\t}\n\t}, {\n\t\tkey: \"dist4\",\n\t\tvalue: function dist4(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.abs(dx) + Math.abs(dy);\n\t\t}\n\t}, {\n\t\tkey: \"dist\",\n\t\tvalue: function dist(xy) {\n\t\t\tvar dx = xy.x - this.x,\n\t\t\t    dy = xy.y - this.y;\n\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t}\n\t}, {\n\t\tkey: \"plus\",\n\t\tvalue: function plus(xy) {\n\t\t\treturn new XY(this.x + xy.x, this.y + xy.y);\n\t\t}\n\t}, {\n\t\tkey: \"minus\",\n\t\tvalue: function minus(xy) {\n\t\t\treturn new XY(this.x - xy.x, this.y - xy.y);\n\t\t}\n\t}]);\n\n\treturn XY;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XY);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PlayerTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return FungusTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return EnemyTemplate; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins__ = __webpack_require__(15);\n\n\n// Player template\nvar PlayerTemplate = {\n    chr: '@',\n    foreground: 'white',\n    background: 'black',\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Moveable, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].PlayerActor]\n};\n\nvar FungusTemplate = {\n    chr: 'F',\n    foreground: 'green',\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].FungusActor]\n};\n\nvar EnemyTemplate = {\n    chr: '☹',\n    foreground: 'red',\n    mixins: [__WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].Moveable, __WEBPACK_IMPORTED_MODULE_0__mixins__[\"a\" /* default */].EnemyActor]\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__glyph__ = __webpack_require__(6);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar Entity = function (_Glyph) {\n    _inherits(Entity, _Glyph);\n\n    function Entity() {\n        var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Entity);\n\n        var _this = _possibleConstructorReturn(this, (Entity.__proto__ || Object.getPrototypeOf(Entity)).call(this, properties));\n\n        _this.name = properties[\"name\"] || \"\";\n        _this.xy = properties[\"xy\"] || 0;\n        _this.map = null;\n        // Create an object which will keep track what mixins we have\n        // attached to this entity based on the name property\n        _this.attachedMixins = {};\n        // Create a similar object for groups\n        _this.attachedMixinGroups = {};\n        // Setup the object's mixins\n        var mixins = properties['mixins'] || [];\n        for (var i = 0; i < mixins.length; i++) {\n            // Copy over all properties from each mixin as long\n            // as it's not the name or the init property. We\n            // also make sure not to override a property that\n            // already exists on the entity.\n            for (var key in mixins[i]) {\n                if (key !== 'init' && key !== 'name' && !_this.hasOwnProperty(key)) {\n                    _this[key] = mixins[i][key];\n                }\n            }\n            // Add the name of this mixin to our attached mixins\n            _this.attachedMixins[mixins[i].name] = true;\n            // If a group name is present, add it\n            if (mixins[i].groupName) {\n                _this.attachedMixinGroups[mixins[i].groupName] = true;\n            }\n            // Finally call the init function if there is one\n            if (mixins[i].init) {\n                mixins[i].init.call(_this, properties);\n            }\n        }\n        return _this;\n    }\n\n    _createClass(Entity, [{\n        key: \"hasMixin\",\n        value: function hasMixin(obj) {\n            // Allow passing the mixin itself or the name / group name as a string\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n                return this.attachedMixins[obj.name];\n            } else {\n                return this.attachedMixins[obj] || this.attachedMixinGroups[obj];\n            }\n        }\n    }]);\n\n    return Entity;\n}(__WEBPACK_IMPORTED_MODULE_0__glyph__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Entity);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// This class is needed to make coloured characters with coloured background.\nvar Glyph = function Glyph() {\n    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Glyph);\n\n    this.chr = properties[\"chr\"] || \"\";\n    this.foreground = properties[\"foreground\"] || \"#ccc\";\n    this.background = properties[\"background\"] || null;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Glyph);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__glyph__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__const__ = __webpack_require__(1);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar Tile = function (_Glyph) {\n    _inherits(Tile, _Glyph);\n\n    function Tile(type) {\n        _classCallCheck(this, Tile);\n\n        var properties = __WEBPACK_IMPORTED_MODULE_1__const__[\"c\" /* Tiles */][type];\n\n        var _this = _possibleConstructorReturn(this, (Tile.__proto__ || Object.getPrototypeOf(Tile)).call(this, properties));\n\n        _this.type = type;\n        _this.isWalkable = properties[\"isWalkable\"] || false;\n        _this.isDiggable = properties[\"isDiggable\"] || false;\n        return _this;\n    }\n\n    return Tile;\n}(__WEBPACK_IMPORTED_MODULE_0__glyph__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Tile);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar asap = __webpack_require__(12);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  __webpack_require__(20).enable();\r\n  window.Promise = __webpack_require__(19);\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\n__webpack_require__(21);\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = __webpack_require__(17);\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(2);\n\n\n\nif (!__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.isSupported()) {\n    alert(\"The rot.js library isn't supported by your browser.\");\n} else {\n    // Initialize the game\n    __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].init();\n}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tile__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__xy__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__entity__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__entities__ = __webpack_require__(4);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\nvar Map = function () {\n    function Map(tiles, player) {\n        _classCallCheck(this, Map);\n\n        this.tiles = tiles;\n        // cache the width and height based\n        // on the length of the dimensions of\n        // the tiles array\n        this.width = tiles.length;\n        this.height = tiles[0].length;\n        // create a list which will hold the entities\n        this.entities = [];\n        // create the engine and scheduler\n        this.scheduler = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Scheduler.Simple();\n        this.engine = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Engine(this.scheduler);\n        // add the player\n        this.addEntityAtRandomPosition(player);\n        // add random fungi\n        for (var i = 0; i < 50; i++) {\n            this.addEntityAtRandomPosition(new __WEBPACK_IMPORTED_MODULE_3__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__entities__[\"b\" /* FungusTemplate */]));\n        }\n        // add enemy\n        this.addEntityAtRandomPosition(new __WEBPACK_IMPORTED_MODULE_3__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__entities__[\"c\" /* EnemyTemplate */]));\n    }\n\n    _createClass(Map, [{\n        key: 'getTile',\n        value: function getTile(xy) {\n            // Make sure we are inside the bounds. If we aren't, return\n            // null tile.\n            if (!this.isInBounds(xy)) {\n                return new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"null\");\n            } else {\n                return this.tiles[xy.x][xy.y] || new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"null\");\n            }\n        }\n    }, {\n        key: 'dig',\n        value: function dig(xy) {\n            if (this.getTile(xy).isDiggable) {\n                this.tiles[xy.x][xy.y] = new __WEBPACK_IMPORTED_MODULE_1__tile__[\"a\" /* default */](\"floor\");\n            }\n        }\n    }, {\n        key: 'getRandomFloorTile',\n        value: function getRandomFloorTile() {\n            var x = void 0,\n                y = void 0;\n            do {\n                x = Math.floor(__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.RNG.getUniform() * this.width);\n                y = Math.floor(__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.RNG.getUniform() * this.width);\n            } while (this.getTile(new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](x, y)).type !== \"floor\" || this.getEntityAt(new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](x, y)));\n            return new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](x, y);\n        }\n    }, {\n        key: 'isInBounds',\n        value: function isInBounds(xy) {\n            return xy.x > 0 && xy.x < this.width && xy.y > 0 && xy.y < this.height;\n        }\n    }, {\n        key: 'getEntityAt',\n        value: function getEntityAt(xy) {\n            for (var i = 0; i < this.entities.length; i++) {\n                if (this.entities[i].xy.is(xy)) {\n                    return this.entities[i];\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'addEntity',\n        value: function addEntity(entity) {\n            // Make sure the entity's position is within bounds\n            if (!this.isInBounds(entity.xy)) {\n                throw new Error('Adding entity out of bounds.');\n            }\n            // Update the entity's map\n            entity.map = this;\n            // Add the entity to the list of entities\n            this.entities.push(entity);\n            // Check if this entity is an actor, and if so add\n            // them to the scheduler\n            if (entity.hasMixin('Actor')) {\n                this.scheduler.add(entity, true);\n            }\n        }\n    }, {\n        key: 'addEntityAtRandomPosition',\n        value: function addEntityAtRandomPosition(entity) {\n            entity.xy = this.getRandomFloorTile();\n            this.addEntity(entity);\n        }\n    }]);\n\n    return Map;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Map);\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GenerateMap;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__map__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__const__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tile__ = __webpack_require__(7);\n\n\n\n\n\nfunction GenerateMap(player) {\n    var map = [];\n    for (var x = 0; x < __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].width; x++) {\n        // Create the nested array for the y values\n        map.push([]);\n        // Add all the tiles\n        for (var y = 0; y < __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].height; y++) {\n            map[x].push(new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"null\"));\n        }\n    }\n    // Setup the map generator\n    var generator = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Map.Digger(__WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].width, __WEBPACK_IMPORTED_MODULE_2__const__[\"b\" /* MapOptions */].height);\n    generator.create(function (x, y, value) {\n        if (value) {\n            map[x][y] = new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"wall\");\n        } else {\n            map[x][y] = new __WEBPACK_IMPORTED_MODULE_3__tile__[\"a\" /* default */](\"floor\");\n        }\n    });\n    // Create our map from the tiles\n    return new __WEBPACK_IMPORTED_MODULE_1__map__[\"a\" /* default */](map, player);\n}\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__xy__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__game__ = __webpack_require__(2);\n\n\n\n\n// Create our Mixins namespace\nvar Mixins = {};\n\n// Define our Moveable mixin\nMixins.Moveable = {\n    name: 'Moveable',\n    tryMove: function tryMove(xy, map) {\n        var tile = map.getTile(xy);\n        // If an entity was present at the tile, then we\n        // can't move there\n        if (map.getEntityAt(xy)) {\n            return false;\n        }\n        // Check if we can walk on the tile\n        // and if so simply walk onto it\n        if (tile.isWalkable) {\n            // Update the entity's position\n            this.xy = xy;\n            return true;\n            // Check if the tile is diggable, and\n            // if so try to dig it\n        } else if (tile.isDiggable) {\n            map.dig(xy);\n            return true;\n        }\n        return false;\n    }\n};\n\nMixins.PlayerActor = {\n    name: 'PlayerActor',\n    groupName: 'Actor',\n    act: function act() {\n        // Re-render the screen\n        __WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].refresh();\n        // Lock the engine and wait asynchronously\n        // for the player to press a key.\n        this.map.engine.lock();\n    }\n};\n\nMixins.FungusActor = {\n    name: 'FungusActor',\n    groupName: 'Actor',\n    act: function act() {}\n};\n\nMixins.EnemyActor = {\n    name: 'EnemyActor',\n    groupName: 'Actor',\n    act: function act() {\n        var _this = this;\n\n        var x = this.map.entities[0].xy.x;\n        var y = this.map.entities[0].xy.y;\n        var passableCallback = function passableCallback(x, y) {\n            return _this.map.getTile(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y)).isWalkable; // && this.map.getEntityAt(new XY(x, y)) <-- this piece of code doesn't work :(\n        };\n        var astar = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Path.AStar(x, y, passableCallback);\n\n        var path = [];\n        var pathCallback = function pathCallback(x, y) {\n            return path.push(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y));\n        };\n        astar.compute(this.xy.x, this.xy.y, pathCallback);\n        x = path[1].x;\n        y = path[1].y;\n        this.tryMove(new __WEBPACK_IMPORTED_MODULE_1__xy__[\"a\" /* default */](x, y), this.map);\n    }\n};\n\nMixins.Teleportable = {\n    name: 'Teleportable',\n    teleport: function teleport(map) {\n        this.xy = map.getRandomFloorTile();\n        return true;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Mixins);\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapgen__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__const__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__xy__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__entity__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__entities__ = __webpack_require__(4);\nvar _this = this;\n\n//  How to make a screen\n//\n//  Screen.name {\n//      enter: () => {\n//          ...\n//      },\n//      exit: () => {\n//          ...\n//      },\n//      render: (display) => {\n//          ...\n//      },\n//      handleInput: (inputType, inputData) => {\n//          ...\n//      },\n//  }\n\n\n\n\n\n\n\n\n\nvar Screen = {};\n\n// Define our initial start screen\nScreen.startScreen = {\n    enter: function enter() {\n        console.log(\"Entered start screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited start screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        display.drawText(1, 1, \"%c{yellow}Javascript Roguelike\");\n        display.drawText(1, 2, \"Press [Enter] to start!\");\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // When [Enter] is pressed, go to the play screen\n        if (inputType === 'keydown') {\n            if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RETURN) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.playScreen);\n            }\n        }\n    }\n};\n\n// Define our playing screen\nScreen.playScreen = {\n    map: null,\n    player: null,\n    enter: function enter() {\n        // Keys for key handling\n        _this.keys = {};\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_K] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_UP] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD8] = 0;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_U] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD9] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PAGE_UP] = 1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_L] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RIGHT] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD6] = 2;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_N] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD3] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PAGE_DOWN] = 3;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_J] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_DOWN] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD2] = 4;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_B] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD1] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_END] = 5;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_H] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_LEFT] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD4] = 6;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_Y] = 7;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD7] = 7;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_HOME] = 7;\n\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PERIOD] = -1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_CLEAR] = -1;\n        _this.keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD5] = -1;\n        _this.move = function (distance) {\n            var newXY = _this.player.xy.plus(distance);\n            // Try to move to the new cell\n            _this.player.tryMove(newXY, _this.map);\n        };\n        _this.player = new __WEBPACK_IMPORTED_MODULE_5__entity__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_6__entities__[\"a\" /* PlayerTemplate */]);\n        _this.map = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__mapgen__[\"a\" /* default */])(_this.player);\n        _this.map.engine.start();\n        console.log(\"Entered play screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited play screen.\");\n    },\n    render: function render(display) {\n        var screenWidth = __WEBPACK_IMPORTED_MODULE_3__const__[\"a\" /* DisplayOptions */].width;\n        var screenHeight = __WEBPACK_IMPORTED_MODULE_3__const__[\"a\" /* DisplayOptions */].height;\n        // Make sure the x-axis doesn't go to the left of the left bound\n        var topLeftX = Math.max(0, _this.player.xy.x - screenWidth / 2);\n        // Make sure we still have enough space to fit an entire game screen\n        topLeftX = Math.floor(Math.min(topLeftX, _this.map.width - screenWidth));\n        // Make sure the y-axis doesn't above the top bound\n        var topLeftY = Math.max(0, _this.player.xy.y - screenHeight / 2);\n        // Make sure we still have enough space to fit an entire game screen\n        topLeftY = Math.floor(Math.min(topLeftY, _this.map.height - screenHeight));\n        // Iterate through all visible map cells\n        for (var x = topLeftX; x < topLeftX + screenWidth; x++) {\n            for (var y = topLeftY; y < topLeftY + screenHeight; y++) {\n                // Fetch the glyph for the tile and render it to the screen\n                // at the offset position.\n                var tile = _this.map.getTile(new __WEBPACK_IMPORTED_MODULE_4__xy__[\"a\" /* default */](x, y));\n                display.draw(x - topLeftX, y - topLeftY, tile.chr, tile.foreground, tile.background);\n            }\n        }\n        // Render the entities\n        var entities = _this.map.entities;\n        for (var i = 0; i < entities.length; i++) {\n            var entity = entities[i];\n            // Only render the entity if they would show up on the screen\n            if (entity.xy.x >= topLeftX && entity.xy.y >= topLeftY && entity.xy.x < topLeftX + screenWidth && entity.xy.y < topLeftY + screenHeight) {\n                display.draw(entity.xy.x - topLeftX, entity.xy.y - topLeftY, entity.chr, entity.foreground, entity.background);\n            }\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        if (inputType === 'keydown') {\n            // If enter is pressed, go to the win screen\n            // If escape is pressed, go to lose screen\n            if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RETURN) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.winScreen);\n            } else if (inputData.keyCode === __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_ESCAPE) {\n                __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].switchScreen(Screen.loseScreen);\n            } else {\n                // Movement\n                if (inputData.keyCode in _this.keys) {\n                    var direction = _this.keys[inputData.keyCode];\n                    if (direction === -1) {\n                        /* noop */\n                        /* FIXME show something? */\n                        return true;\n                    }\n\n                    var dir = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.DIRS[8][direction];\n                    _this.move(new __WEBPACK_IMPORTED_MODULE_4__xy__[\"a\" /* default */](dir[0], dir[1]));\n\n                    // Unlock the engine\n                    _this.map.engine.unlock();\n                }\n            }\n        }\n    }\n};\n\n// Define our winning screen\nScreen.winScreen = {\n    enter: function enter() {\n        console.log(\"Entered win screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited win screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        for (var i = 0; i < 22; i++) {\n            // Generate random background colors\n            var r = Math.round(Math.random() * 255);\n            var g = Math.round(Math.random() * 255);\n            var b = Math.round(Math.random() * 255);\n            var background = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Color.toRGB([r, g, b]);\n            display.drawText(2, i + 1, \"%b{\" + background + \"}You win!\");\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // Nothing to do here\n    }\n};\n\n// Define our losing screen\nScreen.loseScreen = {\n    enter: function enter() {\n        console.log(\"Entered lose screen.\");\n    },\n    exit: function exit() {\n        console.log(\"Exited lose screen.\");\n    },\n    render: function render(display) {\n        // Render our prompt to the screen\n        for (var i = 0; i < 22; i++) {\n            display.drawText(2, i + 1, \"%b{red}You lose! :(\");\n        }\n    },\n    handleInput: function handleInput(inputType, inputData) {\n        // Nothing to do here\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Screen);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(8);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(8);\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(10);\nmodule.exports = __webpack_require__(11);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// static/js/main.3012042d.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dung/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 22);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cd1298cf87e8c9a65c0c","/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rot-js/lib/rot.js\n// module id = 0\n// module chunks = 0","const DisplayOptions = {\r\n    width: 80,\r\n    height: 25\r\n}\r\n\r\nconst MapOptions = {\r\n    width: 80,\r\n    height: 25\r\n}\r\n\r\nconst Tiles = {\r\n    \"null\": {\r\n    },\r\n    floor: {\r\n        chr: \".\",\r\n        foreground: \"#444\",\r\n        background: \"#222\",\r\n        isWalkable: true\r\n    },\r\n    wall: {\r\n        chr: \"#\",\r\n        foreground: \"#777\",\r\n        background: \"#2e2e2e\",\r\n        isDiggable: true\r\n    }\r\n}\r\n\r\nexport {DisplayOptions, MapOptions, Tiles};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","import ROT from 'rot-js'\r\nimport Screen from './screens'\r\nimport {DisplayOptions} from './const'\r\n\r\nclass Game {\r\n    constructor() {\r\n        this.currentScreen = null;\r\n    }\r\n    init() {\r\n        // Initialize display\r\n        this.display = new ROT.Display(DisplayOptions);\r\n        // Append display to the document (HTML file)\r\n        // This creates an <canvas> in the document\r\n        document.body.appendChild(this.display.getContainer());\r\n        // Helper function\r\n        const bindEventToScreen = event => {\r\n            window.addEventListener(event, (e) => {\r\n                // When an event is received, send it to the\r\n                // screen if there is one\r\n                if (this.currentScreen !== null) {\r\n                    // Send the event type and data to the screen\r\n                    this.currentScreen.handleInput(event, e);\r\n                }\r\n            });\r\n        }\r\n        // Bind keyboard input events\r\n        bindEventToScreen('keydown');\r\n        // bindEventToScreen('keyup');\r\n        // bindEventToScreen('keypress');\r\n        this.switchScreen(Screen.startScreen);\r\n    }\r\n    switchScreen(screen) {\r\n        // If we had a screen before, notify it that we exited\r\n        if (this.currentScreen !== null) {\r\n            this.currentScreen.exit();\r\n        }\r\n        // Clear the display\r\n        this.display.clear();\r\n        // Update our current screen, notify it we entered\r\n        // and then render it\r\n        this.currentScreen = screen;\r\n        if (this.currentScreen) {\r\n            this.currentScreen.enter();\r\n            this.refresh();\r\n        }\r\n    }\r\n    refresh() {\r\n        // Clear the screen\r\n        this.display.clear();\r\n        // Render the screen\r\n        this.currentScreen.render(this.display);\r\n    }\r\n}\r\n\r\nconst game = new Game();\r\nexport default game;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","export default class XY {\r\n\tconstructor(x = 0, y = 0) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\ttoString() {\r\n\t\treturn this.x + \",\" + this.y;\r\n\t}\r\n\tis(xy) {\r\n\t\treturn (this.x === xy.x && this.y === xy.y);\r\n\t}\r\n\tdist8(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.max(Math.abs(dx), Math.abs(dy));\r\n\t}\r\n\tdist4(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.abs(dx) + Math.abs(dy);\r\n\t}\r\n\tdist(xy) {\r\n\t\tconst [dx, dy] = [xy.x - this.x, xy.y - this.y];\r\n\t\treturn Math.sqrt(dx*dx+dy*dy);\r\n\t}\r\n\tplus(xy) {\r\n\t\treturn new XY(this.x+xy.x, this.y+xy.y);\r\n\t}\r\n\tminus(xy) {\r\n\t\treturn new XY(this.x-xy.x, this.y-xy.y);\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/xy.js","import Mixins from './mixins'\r\n\r\n// Player template\r\nexport const PlayerTemplate = {\r\n    chr: '@',\r\n    foreground: 'white',\r\n    background: 'black',\r\n    mixins: [Mixins.Moveable, Mixins.PlayerActor]\r\n}\r\n\r\nexport const FungusTemplate = {\r\n    chr: 'F',\r\n    foreground: 'green',\r\n    mixins: [Mixins.FungusActor]\r\n}\r\n\r\nexport const EnemyTemplate = {\r\n    chr: '☹',\r\n    foreground: 'red',\r\n    mixins: [Mixins.Moveable, Mixins.EnemyActor]\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entities.js","import Glyph from './glyph'\r\n\r\nexport default class Entity extends Glyph {\r\n    constructor(properties = {}) {\r\n        super(properties);\r\n        this.name = properties[\"name\"] || \"\";\r\n        this.xy = properties[\"xy\"] || 0;\r\n        this.map = null;\r\n        // Create an object which will keep track what mixins we have\r\n        // attached to this entity based on the name property\r\n        this.attachedMixins = {};\r\n        // Create a similar object for groups\r\n        this.attachedMixinGroups = {};\r\n        // Setup the object's mixins\r\n        const mixins = properties['mixins'] || [];\r\n        for (let i = 0; i < mixins.length; i++) {\r\n            // Copy over all properties from each mixin as long\r\n            // as it's not the name or the init property. We\r\n            // also make sure not to override a property that\r\n            // already exists on the entity.\r\n            for (const key in mixins[i]) {\r\n                if (key !== 'init' && key !== 'name' && !this.hasOwnProperty(key)) {\r\n                    this[key] = mixins[i][key];\r\n                }\r\n            }\r\n            // Add the name of this mixin to our attached mixins\r\n            this.attachedMixins[mixins[i].name] = true;\r\n            // If a group name is present, add it\r\n            if (mixins[i].groupName) {\r\n                this.attachedMixinGroups[mixins[i].groupName] = true;\r\n            }\r\n            // Finally call the init function if there is one\r\n            if (mixins[i].init) {\r\n                mixins[i].init.call(this, properties);\r\n            }\r\n        }\r\n    }\r\n    hasMixin(obj) {\r\n        // Allow passing the mixin itself or the name / group name as a string\r\n        if (typeof obj === 'object') {\r\n            return this.attachedMixins[obj.name];\r\n        } else {\r\n            return this.attachedMixins[obj] || this.attachedMixinGroups[obj];\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entity.js","// This class is needed to make coloured characters with coloured background.\r\nexport default class Glyph {\r\n    constructor(properties = {}) {\r\n        this.chr = properties[\"chr\"] || \"\";\r\n        this.foreground = properties[\"foreground\"] || \"#ccc\";\r\n        this.background = properties[\"background\"] || null;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/glyph.js","import Glyph from './glyph'\r\nimport {Tiles} from './const'\r\n\r\nexport default class Tile extends Glyph {\r\n    constructor(type) {\r\n        const properties = Tiles[type];\r\n        super(properties);\r\n        this.type = type;\r\n        this.isWalkable = properties[\"isWalkable\"] || false;\r\n        this.isDiggable = properties[\"isDiggable\"] || false;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tile.js","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 8\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 9\n// module chunks = 0","'use strict';\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  require('promise/lib/rejection-tracking').enable();\r\n  window.Promise = require('promise/lib/es6-extensions.js');\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\nrequire('whatwg-fetch');\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = require('object-assign');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./config/polyfills.js\n// module id = 10\n// module chunks = 0","import ROT from 'rot-js'\r\nimport game from './game';\r\n\r\nif (!ROT.isSupported()) {\r\n    alert(\"The rot.js library isn't supported by your browser.\");\r\n} else {\r\n    // Initialize the game\r\n    game.init();\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.js’s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 12\n// module chunks = 0","import ROT from 'rot-js'\r\nimport Tile from './tile'\r\nimport XY from './xy'\r\nimport Entity from './entity'\r\nimport {FungusTemplate, EnemyTemplate} from './entities'\r\n\r\nexport default class Map {\r\n    constructor(tiles, player) {\r\n        this.tiles = tiles;\r\n        // cache the width and height based\r\n        // on the length of the dimensions of\r\n        // the tiles array\r\n        this.width = tiles.length;\r\n        this.height = tiles[0].length;\r\n        // create a list which will hold the entities\r\n        this.entities = [];\r\n        // create the engine and scheduler\r\n        this.scheduler = new ROT.Scheduler.Simple();\r\n        this.engine = new ROT.Engine(this.scheduler);\r\n        // add the player\r\n        this.addEntityAtRandomPosition(player);\r\n        // add random fungi\r\n        for (var i = 0; i < 50; i++) {\r\n            this.addEntityAtRandomPosition(new Entity(FungusTemplate));\r\n        }\r\n        // add enemy\r\n        this.addEntityAtRandomPosition(new Entity(EnemyTemplate));\r\n    }\r\n    getTile(xy) {\r\n        // Make sure we are inside the bounds. If we aren't, return\r\n        // null tile.\r\n        if (!this.isInBounds(xy)) {\r\n            return new Tile(\"null\");\r\n        } else {\r\n            return this.tiles[xy.x][xy.y] || new Tile(\"null\");\r\n        }\r\n    }\r\n    dig(xy) {\r\n        if (this.getTile(xy).isDiggable) {\r\n            this.tiles[xy.x][xy.y] = new Tile(\"floor\");\r\n        }\r\n    }\r\n    getRandomFloorTile() {\r\n        let x, y;\r\n        do {\r\n            x = Math.floor(ROT.RNG.getUniform() * this.width);\r\n            y = Math.floor(ROT.RNG.getUniform() * this.width);\r\n        } while(this.getTile(new XY(x, y)).type !== \"floor\" ||\r\n                this.getEntityAt(new XY(x, y)));\r\n        return new XY(x, y);\r\n    }\r\n    isInBounds(xy) {\r\n        return (xy.x > 0 && xy.x < this.width && xy.y > 0 && xy.y < this.height)\r\n    }\r\n    getEntityAt(xy) {\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            if (this.entities[i].xy.is(xy)) {\r\n                return this.entities[i];\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    addEntity(entity) {\r\n        // Make sure the entity's position is within bounds\r\n        if (!this.isInBounds(entity.xy)) {\r\n            throw new Error('Adding entity out of bounds.');\r\n        }\r\n        // Update the entity's map\r\n        entity.map = this;\r\n        // Add the entity to the list of entities\r\n        this.entities.push(entity);\r\n        // Check if this entity is an actor, and if so add\r\n        // them to the scheduler\r\n        if (entity.hasMixin('Actor')) {\r\n           this.scheduler.add(entity, true);\r\n        }\r\n    }\r\n    addEntityAtRandomPosition(entity) {\r\n        entity.xy = this.getRandomFloorTile();\r\n        this.addEntity(entity);\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/map.js","import ROT from 'rot-js'\r\nimport Map from './map'\r\nimport {MapOptions} from './const'\r\nimport Tile from './tile'\r\n\r\nexport default function GenerateMap(player) {\r\n    let map = [];\r\n    for (let x = 0; x < MapOptions.width; x++) {\r\n        // Create the nested array for the y values\r\n        map.push([]);\r\n        // Add all the tiles\r\n        for (var y = 0; y < MapOptions.height; y++) {\r\n            map[x].push(new Tile(\"null\"));\r\n        }\r\n    }\r\n    // Setup the map generator\r\n    const generator = new ROT.Map.Digger(MapOptions.width, MapOptions.height);\r\n    generator.create((x, y, value) => {\r\n        if (value) {\r\n            map[x][y] = new Tile(\"wall\");\r\n        } else {\r\n            map[x][y] = new Tile(\"floor\");\r\n        }\r\n    });\r\n    // Create our map from the tiles\r\n    return new Map(map, player);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/mapgen.js","import ROT from 'rot-js'\r\nimport XY from './xy'\r\nimport game from './game'\r\n\r\n// Create our Mixins namespace\r\nconst Mixins = {};\r\n\r\n// Define our Moveable mixin\r\nMixins.Moveable = {\r\n    name: 'Moveable',\r\n    tryMove: function(xy, map) {\r\n        const tile = map.getTile(xy);\r\n        // If an entity was present at the tile, then we\r\n        // can't move there\r\n        if (map.getEntityAt(xy)) {\r\n            return false;\r\n        }\r\n        // Check if we can walk on the tile\r\n        // and if so simply walk onto it\r\n        if (tile.isWalkable) {\r\n            // Update the entity's position\r\n            this.xy = xy;\r\n            return true;\r\n        // Check if the tile is diggable, and\r\n        // if so try to dig it\r\n        } else if (tile.isDiggable) {\r\n            map.dig(xy);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\nMixins.PlayerActor = {\r\n    name: 'PlayerActor',\r\n    groupName: 'Actor',\r\n    act: function() {\r\n        // Re-render the screen\r\n        game.refresh();\r\n        // Lock the engine and wait asynchronously\r\n        // for the player to press a key.\r\n        this.map.engine.lock();\r\n    }\r\n}\r\n\r\nMixins.FungusActor = {\r\n    name: 'FungusActor',\r\n    groupName: 'Actor',\r\n    act: function() { }\r\n}\r\n\r\nMixins.EnemyActor = {\r\n    name: 'EnemyActor',\r\n    groupName: 'Actor',\r\n    act: function() {\r\n        let x = this.map.entities[0].xy.x;\r\n        let y = this.map.entities[0].xy.y;\r\n        let passableCallback = (x, y) => {\r\n            return this.map.getTile(new XY(x, y)).isWalkable // && this.map.getEntityAt(new XY(x, y)) <-- this piece of code doesn't work :(\r\n        };\r\n        const astar = new ROT.Path.AStar(x, y, passableCallback);\r\n\r\n        let path = [];\r\n        let pathCallback = (x, y) => path.push(new XY(x, y));\r\n        astar.compute(this.xy.x, this.xy.y, pathCallback);\r\n        x = path[1].x;\r\n        y = path[1].y;\r\n        this.tryMove(new XY(x, y), this.map);\r\n    }\r\n}\r\n\r\nMixins.Teleportable = {\r\n    name: 'Teleportable',\r\n    teleport(map) {\r\n        this.xy = map.getRandomFloorTile();\r\n        return true;\r\n    }\r\n}\r\n\r\nexport default Mixins;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins.js","//  How to make a screen\r\n//\r\n//  Screen.name {\r\n//      enter: () => {\r\n//          ...\r\n//      },\r\n//      exit: () => {\r\n//          ...\r\n//      },\r\n//      render: (display) => {\r\n//          ...\r\n//      },\r\n//      handleInput: (inputType, inputData) => {\r\n//          ...\r\n//      },\r\n//  }\r\n\r\nimport ROT from 'rot-js'\r\nimport game from './game'\r\nimport GenerateMap from './mapgen'\r\nimport {DisplayOptions} from './const'\r\nimport XY from './xy'\r\nimport Entity from './entity'\r\nimport {PlayerTemplate} from './entities'\r\n\r\nconst Screen = {};\r\n\r\n// Define our initial start screen\r\nScreen.startScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered start screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited start screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        display.drawText(1,1, \"%c{yellow}Javascript Roguelike\");\r\n        display.drawText(1,2, \"Press [Enter] to start!\");\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // When [Enter] is pressed, go to the play screen\r\n        if (inputType === 'keydown') {\r\n            if (inputData.keyCode === ROT.VK_RETURN) {\r\n                game.switchScreen(Screen.playScreen);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Define our playing screen\r\nScreen.playScreen = {\r\n    map: null,\r\n    player: null,\r\n    enter: () => {\r\n        // Keys for key handling\r\n        this.keys = {};\r\n        this.keys[ROT.VK_K] = 0;\r\n        this.keys[ROT.VK_UP] = 0;\r\n        this.keys[ROT.VK_NUMPAD8] = 0;\r\n        this.keys[ROT.VK_U] = 1;\r\n        this.keys[ROT.VK_NUMPAD9] = 1;\r\n        this.keys[ROT.VK_PAGE_UP] = 1;\r\n        this.keys[ROT.VK_L] = 2;\r\n        this.keys[ROT.VK_RIGHT] = 2;\r\n        this.keys[ROT.VK_NUMPAD6] = 2;\r\n        this.keys[ROT.VK_N] = 3;\r\n        this.keys[ROT.VK_NUMPAD3] = 3;\r\n        this.keys[ROT.VK_PAGE_DOWN] = 3;\r\n        this.keys[ROT.VK_J] = 4;\r\n        this.keys[ROT.VK_DOWN] = 4;\r\n        this.keys[ROT.VK_NUMPAD2] = 4;\r\n        this.keys[ROT.VK_B] = 5;\r\n        this.keys[ROT.VK_NUMPAD1] = 5;\r\n        this.keys[ROT.VK_END] = 5;\r\n        this.keys[ROT.VK_H] = 6;\r\n        this.keys[ROT.VK_LEFT] = 6;\r\n        this.keys[ROT.VK_NUMPAD4] = 6;\r\n        this.keys[ROT.VK_Y] = 7;\r\n        this.keys[ROT.VK_NUMPAD7] = 7;\r\n        this.keys[ROT.VK_HOME] = 7;\r\n\r\n        this.keys[ROT.VK_PERIOD] = -1;\r\n        this.keys[ROT.VK_CLEAR] = -1;\r\n        this.keys[ROT.VK_NUMPAD5] = -1;\r\n        this.move = (distance) => {\r\n            const newXY = this.player.xy.plus(distance);\r\n            // Try to move to the new cell\r\n            this.player.tryMove(newXY, this.map);\r\n        };\r\n        this.player = new Entity(PlayerTemplate);\r\n        this.map = GenerateMap(this.player);\r\n        this.map.engine.start();\r\n        console.log(\"Entered play screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited play screen.\");\r\n    },\r\n    render: (display) => {\r\n        const screenWidth = DisplayOptions.width;\r\n        const screenHeight = DisplayOptions.height;\r\n        // Make sure the x-axis doesn't go to the left of the left bound\r\n        let topLeftX = Math.max(0, this.player.xy.x - (screenWidth / 2));\r\n        // Make sure we still have enough space to fit an entire game screen\r\n        topLeftX = Math.floor(Math.min(topLeftX, this.map.width - screenWidth));\r\n        // Make sure the y-axis doesn't above the top bound\r\n        let topLeftY = Math.max(0, this.player.xy.y - (screenHeight / 2));\r\n        // Make sure we still have enough space to fit an entire game screen\r\n        topLeftY = Math.floor(Math.min(topLeftY, this.map.height - screenHeight));\r\n        // Iterate through all visible map cells\r\n        for (let x = topLeftX; x < topLeftX + screenWidth; x++) {\r\n            for (let y = topLeftY; y < topLeftY + screenHeight; y++) {\r\n                // Fetch the glyph for the tile and render it to the screen\r\n                // at the offset position.\r\n                const tile = this.map.getTile(new XY(x, y));\r\n                display.draw(\r\n                    x - topLeftX,\r\n                    y - topLeftY,\r\n                    tile.chr,\r\n                    tile.foreground,\r\n                    tile.background);\r\n            }\r\n        }\r\n        // Render the entities\r\n        const entities = this.map.entities;\r\n        for (var i = 0; i < entities.length; i++) {\r\n            var entity = entities[i];\r\n            // Only render the entity if they would show up on the screen\r\n            if (entity.xy.x >= topLeftX && entity.xy.y >= topLeftY &&\r\n                entity.xy.x < topLeftX + screenWidth &&\r\n                entity.xy.y < topLeftY + screenHeight) {\r\n                display.draw(\r\n                    entity.xy.x - topLeftX,\r\n                    entity.xy.y - topLeftY,\r\n                    entity.chr,\r\n                    entity.foreground,\r\n                    entity.background\r\n        );\r\n    }\r\n}\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        if (inputType === 'keydown') {\r\n            // If enter is pressed, go to the win screen\r\n            // If escape is pressed, go to lose screen\r\n            if (inputData.keyCode === ROT.VK_RETURN) {\r\n                game.switchScreen(Screen.winScreen);\r\n            } else if (inputData.keyCode === ROT.VK_ESCAPE) {\r\n                game.switchScreen(Screen.loseScreen);\r\n            } else {\r\n                // Movement\r\n                if (inputData.keyCode in this.keys) {\r\n            \t\tconst direction = this.keys[inputData.keyCode];\r\n            \t\tif (direction === -1) { /* noop */\r\n            \t\t\t/* FIXME show something? */\r\n            \t\t\treturn true;\r\n            \t\t}\r\n\r\n            \t\tconst dir = ROT.DIRS[8][direction];\r\n            \t\tthis.move(new XY(dir[0], dir[1]));\r\n\r\n                    // Unlock the engine\r\n                    this.map.engine.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Define our winning screen\r\nScreen.winScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered win screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited win screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        for (let i = 0; i < 22; i++) {\r\n            // Generate random background colors\r\n            const r = Math.round(Math.random() * 255);\r\n            const g = Math.round(Math.random() * 255);\r\n            const b = Math.round(Math.random() * 255);\r\n            const background = ROT.Color.toRGB([r, g, b]);\r\n            display.drawText(2, i + 1, \"%b{\" + background + \"}You win!\");\r\n        }\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // Nothing to do here\r\n    }\r\n}\r\n\r\n// Define our losing screen\r\nScreen.loseScreen = {\r\n    enter: () => {\r\n        console.log(\"Entered lose screen.\");\r\n    },\r\n    exit: () => {\r\n        console.log(\"Exited lose screen.\");\r\n    },\r\n    render: (display) => {\r\n        // Render our prompt to the screen\r\n        for (var i = 0; i < 22; i++) {\r\n            display.drawText(2, i + 1, \"%b{red}You lose! :(\");\r\n        }\r\n    },\r\n    handleInput: (inputType, inputData) => {\r\n        // Nothing to do here\r\n    }\r\n}\r\n\r\nexport default Screen;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/screens.js","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 17\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 18\n// module chunks = 0","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/rejection-tracking.js\n// module id = 20\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}