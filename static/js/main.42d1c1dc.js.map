{"version":3,"sources":["..\\static\\js\\main.42d1c1dc.js","..\\webpack\\bootstrap aa80c946fbb1a4d600bb","game.js","xy.js","entity.js","being.js","..\\node_modules\\promise\\lib\\core.js","..\\node_modules\\rot-js\\lib\\rot.js","..\\node_modules\\webpack\\buildin\\global.js","..\\config\\polyfills.js","index.js","..\\node_modules\\asap\\browser-raw.js","level.js","player.js","textbuffer.js","..\\node_modules\\object-assign\\index.js","..\\node_modules\\process\\browser.js","..\\node_modules\\promise\\lib\\es6-extensions.js","..\\node_modules\\promise\\lib\\rejection-tracking.js","..\\node_modules\\whatwg-fetch\\fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_rot_js__","__WEBPACK_IMPORTED_MODULE_0_rot_js___default","__WEBPACK_IMPORTED_MODULE_3__level__","__WEBPACK_IMPORTED_MODULE_4__player__","__WEBPACK_IMPORTED_MODULE_5__textbuffer__","__WEBPACK_IMPORTED_MODULE_6__xy__","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Game","this","window","addEventListener","e","type","removeEventListener","scheduler","a","Scheduler","Speed","engine","Engine","display","Display","fontSize","textBuffer","document","body","appendChild","getContainer","player","level","size","getSize","_switchLevel","setEntity","Math","round","x","y","start","xy","entity","getEntityAt","visual","getVisual","draw","ch","fg","bg","lock","clear","setOptions","width","height","configure","position","j","beings","getBeings","add","game","XY","toString","is","dist8","dx","dy","max","abs","dist4","dist","sqrt","plus","minus","Entity","_visual","_xy","_level","getXY","getLevel","setPosition","__WEBPACK_IMPORTED_MODULE_0__entity__","__WEBPACK_IMPORTED_MODULE_1__game__","Being","_speed","_hp","extend","getSpeed","damage","die","act","remove","noop","getThen","obj","then","ex","LAST_ERROR","IS_ERROR","tryCallOne","fn","tryCallTwo","b","Promise","_45","_81","_65","_54","doResolve","safeThen","self","onFulfilled","onRejected","constructor","resolve","reject","res","handle","Handler","deferred","_10","push","handleResolved","asap","cb","promise","ret","newValue","finale","bind","_97","done","reason","_61","global","process","requestAnimationFrame","setTimeout","child","scrollLeft","scrollTop","createElement","canvas","getBoundingClientRect","left","top","getContext","_termcolor","beginPath","clearRect","w","h","clearCmd","clearToAnsi","fillStyle","stdout","write","drawImage","f","g","fill","fillRect","fillText","chs","font","lineTo","measureText","moveTo","textAlign","textBaseline","style","visibility","documentElement","ROT","isSupported","Function","DEFAULT_WIDTH","DEFAULT_HEIGHT","DIRS","4","8","6","VK_CANCEL","VK_HELP","VK_BACK_SPACE","VK_TAB","VK_CLEAR","VK_RETURN","VK_ENTER","VK_SHIFT","VK_CONTROL","VK_ALT","VK_PAUSE","VK_CAPS_LOCK","VK_ESCAPE","VK_SPACE","VK_PAGE_UP","VK_PAGE_DOWN","VK_END","VK_HOME","VK_LEFT","VK_UP","VK_RIGHT","VK_DOWN","VK_PRINTSCREEN","VK_INSERT","VK_DELETE","VK_0","VK_1","VK_2","VK_3","VK_4","VK_5","VK_6","VK_7","VK_8","VK_9","VK_COLON","VK_SEMICOLON","VK_LESS_THAN","VK_EQUALS","VK_GREATER_THAN","VK_QUESTION_MARK","VK_AT","VK_A","VK_B","VK_C","VK_D","VK_E","VK_F","VK_G","VK_H","VK_I","VK_J","VK_K","VK_L","VK_M","VK_N","VK_O","VK_P","VK_Q","VK_R","VK_S","VK_T","VK_U","VK_V","VK_W","VK_X","VK_Y","VK_Z","VK_CONTEXT_MENU","VK_NUMPAD0","VK_NUMPAD1","VK_NUMPAD2","VK_NUMPAD3","VK_NUMPAD4","VK_NUMPAD5","VK_NUMPAD6","VK_NUMPAD7","VK_NUMPAD8","VK_NUMPAD9","VK_MULTIPLY","VK_ADD","VK_SEPARATOR","VK_SUBTRACT","VK_DECIMAL","VK_DIVIDE","VK_F1","VK_F2","VK_F3","VK_F4","VK_F5","VK_F6","VK_F7","VK_F8","VK_F9","VK_F10","VK_F11","VK_F12","VK_F13","VK_F14","VK_F15","VK_F16","VK_F17","VK_F18","VK_F19","VK_F20","VK_F21","VK_F22","VK_F23","VK_F24","VK_NUM_LOCK","VK_SCROLL_LOCK","VK_CIRCUMFLEX","VK_EXCLAMATION","VK_DOUBLE_QUOTE","VK_HASH","VK_DOLLAR","VK_PERCENT","VK_AMPERSAND","VK_UNDERSCORE","VK_OPEN_PAREN","VK_CLOSE_PAREN","VK_ASTERISK","VK_PLUS","VK_PIPE","VK_HYPHEN_MINUS","VK_OPEN_CURLY_BRACKET","VK_CLOSE_CURLY_BRACKET","VK_TILDE","VK_COMMA","VK_PERIOD","VK_SLASH","VK_BACK_QUOTE","VK_OPEN_BRACKET","VK_BACK_SLASH","VK_CLOSE_BRACKET","VK_QUOTE","VK_META","VK_ALTGR","VK_WIN","VK_KANA","VK_HANGUL","VK_EISU","VK_JUNJA","VK_FINAL","VK_HANJA","VK_KANJI","VK_CONVERT","VK_NONCONVERT","VK_ACCEPT","VK_MODECHANGE","VK_SELECT","VK_PRINT","VK_EXECUTE","VK_SLEEP","Text","RE_COLORS","TYPE_TEXT","TYPE_NEWLINE","TYPE_FG","TYPE_BG","measure","str","maxWidth","result","tokens","tokenize","lineWidth","token","offset","replace","match","index","part","substring","trim","_breakLines","Infinity","lineLength","lastTokenWithSpace","charAt","indexOf","_breakInsideToken","arr","split","pop","join","nextIndex","breakIndex","lastIndexOf","splice","lastTextToken","tokenIndex","removeBreakChar","newBreakToken","newTextToken","Array","random","floor","RNG","getUniform","randomize","Number","mod","String","capitalize","toUpperCase","lpad","character","count","cnt","rpad","format","template","map","args","slice","arguments","replacer","group1","group2","group","parts","shift","method","toLowerCase","replaced","apply","first","unshift","create","tmp","parent","mozRequestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","options","_context","_data","_dirty","_options","_backend","defaultOptions","transpose","layout","spacing","border","forceSquareRatio","fontFamily","fontStyle","tileWidth","tileHeight","tileMap","tileSet","tileColorize","termColor","DEBUG","_tick","what","colors","compute","getOptions","computeSize","availWidth","availHeight","computeFontSize","eventToPosition","touches","clientX","clientY","rect","drawText","text","cx","cy","lines","isSpace","isPrevSpace","isFullWidth","isPrevFullWidth","cc","charCodeAt","_draw","clearBefore","data","Backend","context","Rect","_spacingX","_spacingY","_canvasCache","cache","charWidth","ceil","_drawWithCache","_drawNoCache","hash","ctx","chars","concat","boxWidth","boxHeight","oldFont","ratio","widthFraction","Hex","_hexSize","xprop","yprop","px","reverse","_fill","hexSizeWidth","hexSizeHeight","hexSize","min","prop","Tile","_colorCanvas","tile","Error","globalCompositeOperation","getSeed","_seed","setSeed","seed","_s0","_frac","_s1","_s2","_c","t","getUniformInt","lowerBound","upperBound","getNormal","mean","stddev","u","v","r","gauss","log","getPercentage","getWeightedValue","total","getState","setState","state","clone","Date","now","StringGenerator","words","order","prior","_boundary","fromCharCode","_suffix","_prefix","_priorValues","generate","_sample","_join","observe","string","_split","event","subcontext","_observeEvent","getStats","priorCount","dataCount","eventCount","_backoff","available","EventQueue","_time","_events","_eventTimes","getTime","time","_remove","_queue","_repeat","_current","item","repeat","next","Simple","Action","_defaultDuration","_duration","setDuration","_scheduler","_lock","unlock","actor","Map","_width","_height","callback","_fillMap","Arena","empty","DividedMaze","_stack","_map","_process","room","_partitionRoom","availX","availY","bottom","right","walls","solid","hole","IceyMaze","regularity","_regularity","nx","ny","blocked","dirs","_randomize","_isFree","EllerMaze","L","R","_addToList","_removeFromList","Cellular","born","survive","topology","connected","_dirs","probability","set","newMap","widthStep","widthStart","cur","ncount","_getNeighbors","_completeMaze","dir","allFreeSpace","notConnected","_freeSpace","_pointKey","_findConnected","keys","_getFromTo","from","to","local","_tunnelToConnected","k","pp","connectedKeys","notConnectedKeys","_getClosest","point","space","minPoint","minDist","stack","keepNotConnected","tests","xx","pkey","yy","Dungeon","_rooms","_corridors","getRooms","getCorridors","Digger","roomWidth","roomHeight","corridorLength","dugPercentage","timeLimit","_features","Room","Corridor","_featureAttempts","_walls","_digCallback","_canBeDugCallback","_isWallCallback","_priorityWallCallback","_dug","area","_firstRoom","t1","wall","_findWall","parseInt","_getDiggingDirection","featureAttempts","_tryFeature","_removeSurroundingWalls","priorityWalls","_addDoors","Feature","createRandomCenter","prio1","prio2","feature","createRandomAt","isValid","createPriorityWalls","deltas","delta","isWallCallback","clearDoors","addDoors","Uniform","roomDugPercentage","_roomAttempts","_corridorAttempts","_connected","_unconnected","_generateRooms","_generateCorridors","_generateRoom","createRandom","room1","_closestRoom","room2","_connectRooms","rooms","center","getCenter","center1","center2","diffX","diffY","dirIndex1","dirIndex2","getLeft","getRight","getTop","getBottom","_placeInWall","end","_digLine","diff","rotation","mid","index2","mid1","mid2","addDoor","dirIndex","avail","lastBadIndex","points","corridor","Rogue","cellWidth","cellHeight","_calculateRoomSize","connectedCells","_initRooms","_connectUnconnectedRooms","_createRandomRoomConnections","_createRooms","_createCorridors","cell","connections","cellx","celly","idx","ncgx","ncgy","otherRoom","cgx","cgy","found","dirToCheck","cw","validRoom","directions","dirIdx","newI","newJ","console","roomw","roomh","sx","sy","cwp","chp","sxOffset","syOffset","ii","jj","_getWallPosition","aRoom","aDirection","rx","ry","door","_drawCorridore","startPosition","endPosition","tempDist","xDir","yDir","move","xOffset","yOffset","xpos","ypos","moves","xAbs","yAbs","percent","firstHalf","secondHalf","connection","otherWall","canBeDugCallback","digCallback","debug","x1","y1","x2","y2","doorX","doorY","_x1","_y1","_x2","_y2","_doors","getDoors","startX","startY","endX","endY","_startX","_startY","_endX","_endY","_endsWithAWall","ok","firstCornerBad","secondCornerBad","priorityWallCallback","Noise","Simplex","gradients","_F2","_G2","_gradients","permutations","_perms","_indexes","xin","yin","gi","i1","j1","perms","indexes","G2","n0","n1","n2","X0","Y0","x0","y0","t0","grad","t2","FOV","lightPassesCallback","_lightPasses","_getCircle","countFactor","startOffset","DiscreteShadowcasting","_coords","A","B","blocks","DATA","neighbors","angle","_visibleCoords","v1","callee","v2","PreciseShadowcasting","A1","A2","SHADOWS","neighborCount","_checkVisibility","index1","edge1","old","edge2","visible","visibleLength","P","P1","P2","RecursiveShadowcasting","OCTANTS","_renderOctant","compute180","previousOctant","nextPreviousOctant","nextOctant","compute90","octant","_castVisibility","row","visSlopeStart","visSlopeEnd","radius","yx","newStart","mapX","mapY","slopeStart","slopeEnd","Color","fromString","cached","_cache","values","color1","color2","add_","multiply","multiply_","interpolate","factor","interpolateHSL","hsl1","rgb2hsl","hsl2","hsl2rgb","color","hue2rgb","q","toRGB","_clamp","toHex","num","black","navy","darkblue","mediumblue","blue","darkgreen","green","teal","darkcyan","deepskyblue","darkturquoise","mediumspringgreen","lime","springgreen","aqua","cyan","midnightblue","dodgerblue","forestgreen","seagreen","darkslategray","darkslategrey","limegreen","mediumseagreen","turquoise","royalblue","steelblue","darkslateblue","mediumturquoise","indigo","darkolivegreen","cadetblue","cornflowerblue","mediumaquamarine","dimgray","dimgrey","slateblue","olivedrab","slategray","slategrey","lightslategray","lightslategrey","mediumslateblue","lawngreen","chartreuse","aquamarine","maroon","purple","olive","gray","grey","skyblue","lightskyblue","blueviolet","darkred","darkmagenta","saddlebrown","darkseagreen","lightgreen","mediumpurple","darkviolet","palegreen","darkorchid","yellowgreen","sienna","brown","darkgray","darkgrey","lightblue","greenyellow","paleturquoise","lightsteelblue","powderblue","firebrick","darkgoldenrod","mediumorchid","rosybrown","darkkhaki","silver","mediumvioletred","indianred","peru","chocolate","tan","lightgray","lightgrey","palevioletred","thistle","orchid","goldenrod","crimson","gainsboro","plum","burlywood","lightcyan","lavender","darksalmon","violet","palegoldenrod","lightcoral","khaki","aliceblue","honeydew","azure","sandybrown","wheat","beige","whitesmoke","mintcream","ghostwhite","salmon","antiquewhite","linen","lightgoldenrodyellow","oldlace","red","fuchsia","magenta","deeppink","orangered","tomato","hotpink","coral","darkorange","lightsalmon","orange","lightpink","pink","gold","peachpuff","navajowhite","moccasin","bisque","mistyrose","blanchedalmond","papayawhip","lavenderblush","seashell","cornsilk","lemonchiffon","floralwhite","snow","yellow","lightyellow","ivory","white","Lighting","reflectivityCallback","_reflectivityCallback","passes","emissionThreshold","range","_fov","_lights","_reflectivityCache","_fovCache","reset","setFOV","fov","setLight","clearLights","lightingCallback","doneCells","emittingCells","litCells","light","_emitLight","_computeEmitters","litKey","_emitLightFromCell","reflectivity","emission","intensity","_updateFOV","fovKey","formFactor","key1","vis","key2","Path","toX","toY","passableCallback","_toX","_toY","_fromX","_fromY","_passableCallback","fromX","fromY","Dijkstra","_computed","_todo","_add","_compute","prev","neighbor","AStar","_done","_distance","Term","_cx","_cy","_lastColor","_ox","_oy","columns","rows","positionToAnsi","newColor","colorToAnsi","Xterm","rgb","eval","enable","assign","init","rawAsap","task","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromTimer","handleTimer","timeoutHandle","clearInterval","intervalHandle","setInterval","scope","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","toggle","observer","node","createTextNode","characterData","__WEBPACK_IMPORTED_MODULE_2__xy__","Level","_beings","_size","_empty","oldXY","__WEBPACK_IMPORTED_MODULE_1__being__","__WEBPACK_IMPORTED_MODULE_2__game__","__WEBPACK_IMPORTED_MODULE_3__xy__","Player","_keys","over","handleEvent","keyCode","_handleKey","code","direction","__WEBPACK_IMPORTED_MODULE_0__xy__","TextBuffer","pos","toObject","val","undefined","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","test1","getOwnPropertyNames","test2","test3","forEach","letter","err","source","symbols","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","len","run","Item","array","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","remaining","race","disable","enabled","onUnhandled","allRejections","matchWhitelist","rejections","error","whitelist","DEFAULT_WHITELIST","displayId","logged","logError","onHandled","warn","_72","line","list","some","cls","ReferenceError","RangeError","normalizeName","test","normalizeValue","iteratorFor","items","iterator","support","iterable","Symbol","Headers","headers","append","isArray","header","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","bufferClone","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","isDataView","_bodyArrayBuffer","ArrayBuffer","isArrayBufferView","rejected","decode","json","JSON","parse","normalizeMethod","upcased","methods","Request","input","url","credentials","mode","referrer","form","bytes","decodeURIComponent","parseHeaders","rawHeaders","Response","bodyInit","status","statusText","fetch","viewClasses","DataView","isView","oldValue","has","thisArg","entries","response","redirectStatuses","redirect","location","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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","file":"static/js/main.42d1c1dc.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dung/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 18);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__being__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__level__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__player__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__textbuffer__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__xy__ = __webpack_require__(1);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\n\n\n\nvar Game = function () {\n\tfunction Game() {\n\t\t_classCallCheck(this, Game);\n\t}\n\n\t_createClass(Game, [{\n\t\tkey: 'init',\n\t\tvalue: function init() {\n\t\t\twindow.addEventListener(\"load\", this);\n\t\t}\n\t}, {\n\t\tkey: 'handleEvent',\n\t\tvalue: function handleEvent(e) {\n\t\t\tswitch (e.type) {\n\t\t\t\tcase \"load\":\n\t\t\t\t\twindow.removeEventListener(\"load\", this);\n\n\t\t\t\t\tthis.scheduler = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Scheduler.Speed();\n\t\t\t\t\tthis.engine = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Engine(this.scheduler);\n\t\t\t\t\tthis.display = new __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.Display({ fontSize: 16 });\n\t\t\t\t\tthis.textBuffer = new __WEBPACK_IMPORTED_MODULE_5__textbuffer__[\"a\" /* default */](this.display);\n\t\t\t\t\tdocument.body.appendChild(this.display.getContainer());\n\t\t\t\t\tthis.player = new __WEBPACK_IMPORTED_MODULE_4__player__[\"a\" /* default */]();\n\n\t\t\t\t\t/* FIXME build a level and position a player */\n\t\t\t\t\tvar level = new __WEBPACK_IMPORTED_MODULE_3__level__[\"a\" /* default */]();\n\t\t\t\t\tvar size = level.getSize();\n\t\t\t\t\tthis._switchLevel(level);\n\t\t\t\t\tthis.level.setEntity(this.player, new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](Math.round(size.x / 2), Math.round(size.y / 2)));\n\n\t\t\t\t\tthis.engine.start();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'draw',\n\t\tvalue: function draw(xy) {\n\t\t\tvar entity = this.level.getEntityAt(xy);\n\t\t\tvar visual = entity.getVisual();\n\t\t\tthis.display.draw(xy.x, xy.y, visual.ch, visual.fg, visual.bg);\n\t\t}\n\t}, {\n\t\tkey: 'over',\n\t\tvalue: function over() {\n\t\t\tthis.engine.lock();\n\t\t\t/* FIXME show something */\n\t\t}\n\t}, {\n\t\tkey: '_switchLevel',\n\t\tvalue: function _switchLevel(level) {\n\t\t\t/* remove old beings from the scheduler */\n\t\t\tthis.scheduler.clear();\n\n\t\t\tthis.level = level;\n\t\t\tvar size = this.level.getSize();\n\n\t\t\tvar bufferSize = 3;\n\t\t\tthis.display.setOptions({ width: size.x, height: size.y + bufferSize });\n\t\t\tthis.textBuffer.configure({\n\t\t\t\tdisplay: this.display,\n\t\t\t\tposition: new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](0, size.y),\n\t\t\t\tsize: new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */](size.x, bufferSize)\n\t\t\t});\n\t\t\tthis.textBuffer.clear();\n\n\t\t\t/* FIXME draw a level */\n\t\t\tvar xy = new __WEBPACK_IMPORTED_MODULE_6__xy__[\"a\" /* default */]();\n\t\t\tfor (var i = 0; i < size.x; i++) {\n\t\t\t\txy.x = i;\n\t\t\t\tfor (var j = 0; j < size.y; j++) {\n\t\t\t\t\txy.y = j;\n\t\t\t\t\tthis.draw(xy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* add new beings to the scheduler */\n\t\t\tvar beings = this.level.getBeings();\n\t\t\tfor (var p in beings) {\n\t\t\t\tthis.scheduler.add(beings[p], true);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Game;\n}();\n\nGame.scheduler = null;\nGame.engine = null;\nGame.player = null;\nGame.level = null;\nGame.display = null;\nGame.textBuffer = null;\n\n\nvar game = new Game();\n/* harmony default export */ __webpack_exports__[\"a\"] = (game);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar XY = function XY(x, y) {\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n};\n\nXY.prototype.toString = function () {\n\treturn this.x + \",\" + this.y;\n};\n\nXY.prototype.is = function (xy) {\n\treturn this.x === xy.x && this.y === xy.y;\n};\n\nXY.prototype.dist8 = function (xy) {\n\tvar dx = xy.x - this.x;\n\tvar dy = xy.y - this.y;\n\treturn Math.max(Math.abs(dx), Math.abs(dy));\n};\n\nXY.prototype.dist4 = function (xy) {\n\tvar dx = xy.x - this.x;\n\tvar dy = xy.y - this.y;\n\treturn Math.abs(dx) + Math.abs(dy);\n};\n\nXY.prototype.dist = function (xy) {\n\tvar dx = xy.x - this.x;\n\tvar dy = xy.y - this.y;\n\treturn Math.sqrt(dx * dx + dy * dy);\n};\n\nXY.prototype.plus = function (xy) {\n\treturn new XY(this.x + xy.x, this.y + xy.y);\n};\n\nXY.prototype.minus = function (xy) {\n\treturn new XY(this.x - xy.x, this.y - xy.y);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XY);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar Entity = function Entity(visual) {\n\tthis._visual = visual;\n\tthis._xy = null;\n\tthis._level = null;\n};\n\nEntity.prototype.getVisual = function () {\n\treturn this._visual;\n};\n\nEntity.prototype.getXY = function () {\n\treturn this._xy;\n};\n\nEntity.prototype.getLevel = function () {\n\treturn this._level;\n};\n\nEntity.prototype.setPosition = function (xy, level) {\n\tthis._xy = xy;\n\tthis._level = level;\n\treturn this;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Entity);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(0);\n\n\n\nvar Being = function Being(visual) {\n\t__WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */].call(this, visual);\n\n\tthis._speed = 100;\n\tthis._hp = 10;\n};\nBeing.extend(__WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */]);\n\n/**\r\n * Called by the Scheduler\r\n */\nBeing.prototype.getSpeed = function () {\n\treturn this._speed;\n};\n\nBeing.prototype.damage = function (damage) {\n\tthis._hp -= damage;\n\tif (this._hp <= 0) {\n\t\tthis.die();\n\t}\n};\n\nBeing.prototype.act = function () {\n\t/* FIXME */\n};\n\nBeing.prototype.die = function () {\n\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].scheduler.remove(this);\n};\n\nBeing.prototype.setPosition = function (xy, level) {\n\t/* came to a currently active level; add self to the scheduler */\n\tif (level !== this._level && level === __WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level) {\n\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].scheduler.add(this, true);\n\t}\n\n\treturn __WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */].prototype.setPosition.call(this, xy, level);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Being);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar asap = __webpack_require__(9);\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/**  key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baage.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Bjrn Bergstrm's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(14)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  __webpack_require__(16).enable();\r\n  window.Promise = __webpack_require__(15);\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\n__webpack_require__(17);\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = __webpack_require__(13);\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__game__ = __webpack_require__(0);\n\n\n__WEBPACK_IMPORTED_MODULE_0__game__[\"a\" /* default */].init();\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__entity__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__game__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__xy__ = __webpack_require__(1);\n\n\n\n\nvar Level = function Level() {\n\t/* FIXME data structure for storing entities */\n\tthis._beings = {};\n\n\t/* FIXME map data */\n\tthis._size = new __WEBPACK_IMPORTED_MODULE_2__xy__[\"a\" /* default */](80, 25);\n\tthis._map = {};\n\n\tthis._empty = new __WEBPACK_IMPORTED_MODULE_0__entity__[\"a\" /* default */]({ ch: \".\", fg: \"#888\", bg: null });\n};\n\nLevel.prototype.getSize = function () {\n\treturn this._size;\n};\n\nLevel.prototype.setEntity = function (entity, xy) {\n\t/* FIXME remove from old position, draw */\n\tif (entity.getLevel() === this) {\n\t\tvar oldXY = entity.getXY();\n\t\tdelete this._beings[oldXY];\n\t\tif (__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level === this) {\n\t\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].draw(oldXY);\n\t\t}\n\t}\n\n\tentity.setPosition(xy, this); /* propagate position data to the entity itself */\n\n\t/* FIXME set new position, draw */\n\tthis._beings[xy] = entity;\n\tif (__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].level === this) {\n\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].draw(xy);\n\t\t__WEBPACK_IMPORTED_MODULE_1__game__[\"a\" /* default */].textBuffer.write(\"An entity moves to \" + xy + \".\");\n\t}\n};\n\nLevel.prototype.getEntityAt = function (xy) {\n\treturn this._beings[xy] || this._map[xy] || this._empty;\n};\n\nLevel.prototype.getBeings = function () {\n\t/* FIXME list of all beings */\n\treturn this._beings;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Level);\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rot_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__being__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__game__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__xy__ = __webpack_require__(1);\n\n\n\n\n\nvar Player = function Player() {\n\t__WEBPACK_IMPORTED_MODULE_1__being__[\"a\" /* default */].call(this, { ch: \"@\", fg: \"#fff\" });\n\n\tthis._keys = {};\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_K] = 0;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_UP] = 0;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD8] = 0;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_U] = 1;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD9] = 1;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_L] = 2;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_RIGHT] = 2;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD6] = 2;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_N] = 3;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD3] = 3;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_J] = 4;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_DOWN] = 4;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD2] = 4;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_B] = 5;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD1] = 5;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_H] = 6;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_LEFT] = 6;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD4] = 6;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_Y] = 7;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD7] = 7;\n\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_PERIOD] = -1;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_CLEAR] = -1;\n\tthis._keys[__WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.VK_NUMPAD5] = -1;\n};\nPlayer.extend(__WEBPACK_IMPORTED_MODULE_1__being__[\"a\" /* default */]);\n\nPlayer.prototype.act = function () {\n\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.write(\"It is your turn, press any relevant key.\");\n\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.flush();\n\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].engine.lock();\n\twindow.addEventListener(\"keydown\", this);\n};\n\nPlayer.prototype.die = function () {\n\t__WEBPACK_IMPORTED_MODULE_1__being__[\"a\" /* default */].prototype.die.call(this);\n\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].over();\n};\n\nPlayer.prototype.handleEvent = function (e) {\n\tvar code = e.keyCode;\n\n\tvar keyHandled = this._handleKey(e.keyCode);\n\n\tif (keyHandled) {\n\t\twindow.removeEventListener(\"keydown\", this);\n\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].engine.unlock();\n\t}\n};\n\nPlayer.prototype._handleKey = function (code) {\n\tif (code in this._keys) {\n\t\t__WEBPACK_IMPORTED_MODULE_2__game__[\"a\" /* default */].textBuffer.clear();\n\n\t\tvar direction = this._keys[code];\n\t\tif (direction === -1) {\n\t\t\t/* noop */\n\t\t\t/* FIXME show something? */\n\t\t\treturn true;\n\t\t}\n\n\t\tvar dir = __WEBPACK_IMPORTED_MODULE_0_rot_js___default.a.DIRS[8][direction];\n\t\tvar xy = this._xy.plus(new __WEBPACK_IMPORTED_MODULE_3__xy__[\"a\" /* default */](dir[0], dir[1]));\n\n\t\tthis._level.setEntity(this, xy); /* FIXME collision detection */\n\t\treturn true;\n\t}\n\n\treturn false; /* unknown key */\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Player);\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__xy__ = __webpack_require__(1);\n\n\nvar TextBuffer = function TextBuffer() {\n\tthis._data = [];\n\tthis._options = {\n\t\tdisplay: null,\n\t\tposition: new __WEBPACK_IMPORTED_MODULE_0__xy__[\"a\" /* default */](),\n\t\tsize: new __WEBPACK_IMPORTED_MODULE_0__xy__[\"a\" /* default */]()\n\t};\n};\n\nTextBuffer.prototype.configure = function (options) {\n\tfor (var p in options) {\n\t\tthis._options[p] = options[p];\n\t}\n};\n\nTextBuffer.prototype.clear = function () {\n\tthis._data = [];\n};\n\nTextBuffer.prototype.write = function (text) {\n\tthis._data.push(text);\n};\n\nTextBuffer.prototype.flush = function () {\n\tvar o = this._options;\n\tvar d = o.display;\n\tvar pos = o.position;\n\tvar size = o.size;\n\n\t/* clear */\n\tfor (var i = 0; i < size.x; i++) {\n\t\tfor (var j = 0; j < size.y; j++) {\n\t\t\td.draw(pos.x + i, pos.y + j);\n\t\t}\n\t}\n\n\tvar text = this._data.join(\" \");\n\td.drawText(pos.x, pos.y, text, size.x);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TextBuffer);\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(4);\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(4);\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(7);\nmodule.exports = __webpack_require__(8);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// static/js/main.42d1c1dc.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dung/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap aa80c946fbb1a4d600bb","import ROT from 'rot-js'\r\nimport Being from './being'\r\nimport Entity from './entity'\r\nimport Level from './level'\r\nimport Player from './player'\r\nimport TextBuffer from './textbuffer'\r\nimport XY from './xy'\r\n\r\nclass Game {\r\n\tstatic scheduler = null\r\n\tstatic engine = null\r\n\tstatic player = null\r\n\tstatic level = null\r\n\tstatic display = null\r\n\tstatic textBuffer = null\r\n\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\t\twindow.addEventListener(\"load\", this);\r\n\t}\r\n\r\n\thandleEvent(e) {\r\n\t\tswitch (e.type) {\r\n\t\t\tcase \"load\":\r\n\t\t\t\twindow.removeEventListener(\"load\", this);\r\n\r\n\t\t\t\tthis.scheduler = new ROT.Scheduler.Speed();\r\n\t\t\t\tthis.engine = new ROT.Engine(this.scheduler);\r\n\t\t\t\tthis.display = new ROT.Display({fontSize:16});\r\n\t\t\t\tthis.textBuffer = new TextBuffer(this.display);\r\n\t\t\t\tdocument.body.appendChild(this.display.getContainer());\r\n\t\t\t\tthis.player = new Player();\r\n\r\n\t\t\t\t/* FIXME build a level and position a player */\r\n\t\t\t\tvar level = new Level();\r\n\t\t\t\tvar size = level.getSize();\r\n\t\t\t\tthis._switchLevel(level);\r\n\t\t\t\tthis.level.setEntity(this.player, new XY(Math.round(size.x/2), Math.round(size.y/2)));\r\n\r\n\t\t\t\tthis.engine.start();\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tdraw(xy) {\r\n\t\tvar entity = this.level.getEntityAt(xy);\r\n\t\tvar visual = entity.getVisual();\r\n\t\tthis.display.draw(xy.x, xy.y, visual.ch, visual.fg, visual.bg);\r\n\t}\r\n\r\n\tover() {\r\n\t\tthis.engine.lock();\r\n\t\t/* FIXME show something */\r\n\t}\r\n\r\n\t_switchLevel(level) {\r\n\t\t/* remove old beings from the scheduler */\r\n\t\tthis.scheduler.clear();\r\n\r\n\t\tthis.level = level;\r\n\t\tvar size = this.level.getSize();\r\n\r\n\t\tvar bufferSize = 3;\r\n\t\tthis.display.setOptions({width:size.x, height:size.y + bufferSize});\r\n\t\tthis.textBuffer.configure({\r\n\t\t\tdisplay: this.display,\r\n\t\t\tposition: new XY(0, size.y),\r\n\t\t\tsize: new XY(size.x, bufferSize)\r\n\t\t});\r\n\t\tthis.textBuffer.clear();\r\n\r\n\t\t/* FIXME draw a level */\r\n\t\tvar xy = new XY();\r\n\t\tfor (var i=0;i<size.x;i++) {\r\n\t\t\txy.x = i;\r\n\t\t\tfor (var j=0;j<size.y;j++) {\r\n\t\t\t\txy.y = j;\r\n\t\t\t\tthis.draw(xy);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* add new beings to the scheduler */\r\n\t\tvar beings = this.level.getBeings();\r\n\t\tfor (var p in beings) {\r\n\t\t\tthis.scheduler.add(beings[p], true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst game = new Game();\r\nexport default game;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","var XY = function(x, y) {\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n}\r\n\r\nXY.prototype.toString = function() {\r\n\treturn this.x+\",\"+this.y;\r\n}\r\n\r\nXY.prototype.is = function(xy) {\r\n\treturn (this.x===xy.x && this.y===xy.y);\r\n}\r\n\r\nXY.prototype.dist8 = function(xy) {\r\n\tvar dx = xy.x-this.x;\r\n\tvar dy = xy.y-this.y;\r\n\treturn Math.max(Math.abs(dx), Math.abs(dy));\r\n}\r\n\r\nXY.prototype.dist4 = function(xy) {\r\n\tvar dx = xy.x-this.x;\r\n\tvar dy = xy.y-this.y;\r\n\treturn Math.abs(dx) + Math.abs(dy);\r\n}\r\n\r\nXY.prototype.dist = function(xy) {\r\n\tvar dx = xy.x-this.x;\r\n\tvar dy = xy.y-this.y;\r\n\treturn Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\nXY.prototype.plus = function(xy) {\r\n\treturn new XY(this.x+xy.x, this.y+xy.y);\r\n}\r\n\r\nXY.prototype.minus = function(xy) {\r\n\treturn new XY(this.x-xy.x, this.y-xy.y);\r\n}\r\n\r\nexport default XY;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/xy.js","var Entity = function(visual) {\r\n\tthis._visual = visual;\r\n\tthis._xy = null;\r\n\tthis._level = null;\r\n}\r\n\r\nEntity.prototype.getVisual = function() {\r\n\treturn this._visual;\r\n}\r\n\r\nEntity.prototype.getXY = function() {\r\n\treturn this._xy;\r\n}\r\n\r\nEntity.prototype.getLevel = function() {\r\n\treturn this._level;\r\n}\r\n\r\nEntity.prototype.setPosition = function(xy, level) {\r\n\tthis._xy = xy;\r\n\tthis._level = level;\r\n\treturn this;\r\n}\r\n\r\nexport default Entity;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/entity.js","import Entity from './entity'\r\nimport Game from './game'\r\n\r\nvar Being = function(visual) {\r\n\tEntity.call(this, visual);\r\n\r\n\tthis._speed = 100;\r\n\tthis._hp = 10;\r\n}\r\nBeing.extend(Entity);\r\n\r\n/**\r\n * Called by the Scheduler\r\n */\r\nBeing.prototype.getSpeed = function() {\r\n\treturn this._speed;\r\n}\r\n\r\nBeing.prototype.damage = function(damage) {\r\n\tthis._hp -= damage;\r\n\tif (this._hp <= 0) { this.die(); }\r\n}\r\n\r\nBeing.prototype.act = function() {\r\n\t/* FIXME */\r\n}\r\n\r\nBeing.prototype.die = function() {\r\n\tGame.scheduler.remove(this);\r\n}\r\n\r\nBeing.prototype.setPosition = function(xy, level) {\r\n\t/* came to a currently active level; add self to the scheduler */\r\n\tif (level !== this._level && level === Game.level) {\r\n\t\tGame.scheduler.add(this, true);\r\n\t}\r\n\r\n\treturn Entity.prototype.setPosition.call(this, xy, level);\r\n}\r\n\r\nexport default Being;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/being.js","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 4\n// module chunks = 0","/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/**  key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baage.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Bjrn Bergstrm's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rot-js/lib/rot.js\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0","'use strict';\r\n\r\nif (typeof Promise === 'undefined') {\r\n  // Rejection tracking prevents a common issue where React gets into an\r\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\r\n  // and the user has no idea what causes React's erratic future behavior.\r\n  require('promise/lib/rejection-tracking').enable();\r\n  window.Promise = require('promise/lib/es6-extensions.js');\r\n}\r\n\r\n// fetch() polyfill for making API calls.\r\nrequire('whatwg-fetch');\r\n\r\n// Object.assign() is commonly used with React.\r\n// It will use the native implementation if it's present and isn't buggy.\r\nObject.assign = require('object-assign');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./config/polyfills.js\n// module id = 7\n// module chunks = 0","import game from './game';\r\n\r\ngame.init();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 9\n// module chunks = 0","import Entity from './entity'\r\nimport Game from './game'\r\nimport XY from './xy'\r\n\r\nvar Level = function() {\r\n\t/* FIXME data structure for storing entities */\r\n\tthis._beings = {};\r\n\r\n\t/* FIXME map data */\r\n\tthis._size = new XY(80, 25);\r\n\tthis._map = {};\r\n\r\n\tthis._empty = new Entity({ch:\".\", fg:\"#888\", bg:null});\r\n}\r\n\r\nLevel.prototype.getSize = function() {\r\n\treturn this._size;\r\n}\r\n\r\nLevel.prototype.setEntity = function(entity, xy) {\r\n\t/* FIXME remove from old position, draw */\r\n\tif (entity.getLevel() === this) {\r\n\t\tvar oldXY = entity.getXY();\r\n\t\tdelete this._beings[oldXY];\r\n\t\tif (Game.level === this) { Game.draw(oldXY); }\r\n\t}\r\n\r\n\tentity.setPosition(xy, this); /* propagate position data to the entity itself */\r\n\r\n\t/* FIXME set new position, draw */\r\n\tthis._beings[xy] = entity;\r\n\tif (Game.level === this) {\r\n\t\tGame.draw(xy);\r\n\t\tGame.textBuffer.write(\"An entity moves to \" + xy + \".\");\r\n\t}\r\n}\r\n\r\nLevel.prototype.getEntityAt = function(xy) {\r\n\treturn this._beings[xy] || this._map[xy] || this._empty;\r\n}\r\n\r\nLevel.prototype.getBeings = function() {\r\n\t/* FIXME list of all beings */\r\n\treturn this._beings;\r\n}\r\n\r\nexport default Level;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/level.js","import ROT from 'rot-js'\r\nimport Being from './being'\r\nimport Game from './game'\r\nimport XY from './xy'\r\n\r\nvar Player = function() {\r\n\tBeing.call(this, {ch:\"@\", fg:\"#fff\"});\r\n\r\n\tthis._keys = {};\r\n\tthis._keys[ROT.VK_K] = 0;\r\n\tthis._keys[ROT.VK_UP] = 0;\r\n\tthis._keys[ROT.VK_NUMPAD8] = 0;\r\n\tthis._keys[ROT.VK_U] = 1;\r\n\tthis._keys[ROT.VK_NUMPAD9] = 1;\r\n\tthis._keys[ROT.VK_L] = 2;\r\n\tthis._keys[ROT.VK_RIGHT] = 2;\r\n\tthis._keys[ROT.VK_NUMPAD6] = 2;\r\n\tthis._keys[ROT.VK_N] = 3;\r\n\tthis._keys[ROT.VK_NUMPAD3] = 3;\r\n\tthis._keys[ROT.VK_J] = 4;\r\n\tthis._keys[ROT.VK_DOWN] = 4;\r\n\tthis._keys[ROT.VK_NUMPAD2] = 4;\r\n\tthis._keys[ROT.VK_B] = 5;\r\n\tthis._keys[ROT.VK_NUMPAD1] = 5;\r\n\tthis._keys[ROT.VK_H] = 6;\r\n\tthis._keys[ROT.VK_LEFT] = 6;\r\n\tthis._keys[ROT.VK_NUMPAD4] = 6;\r\n\tthis._keys[ROT.VK_Y] = 7;\r\n\tthis._keys[ROT.VK_NUMPAD7] = 7;\r\n\r\n\tthis._keys[ROT.VK_PERIOD] = -1;\r\n\tthis._keys[ROT.VK_CLEAR] = -1;\r\n\tthis._keys[ROT.VK_NUMPAD5] = -1;\r\n}\r\nPlayer.extend(Being);\r\n\r\nPlayer.prototype.act = function() {\r\n\tGame.textBuffer.write(\"It is your turn, press any relevant key.\");\r\n\tGame.textBuffer.flush();\r\n\tGame.engine.lock();\r\n\twindow.addEventListener(\"keydown\", this);\r\n}\r\n\r\nPlayer.prototype.die = function() {\r\n\tBeing.prototype.die.call(this);\r\n\tGame.over();\r\n}\r\n\r\nPlayer.prototype.handleEvent = function(e) {\r\n\tvar code = e.keyCode;\r\n\r\n\tvar keyHandled = this._handleKey(e.keyCode);\r\n\r\n\tif (keyHandled) {\r\n\t\twindow.removeEventListener(\"keydown\", this);\r\n\t\tGame.engine.unlock();\r\n\t}\r\n}\r\n\r\nPlayer.prototype._handleKey = function(code) {\r\n\tif (code in this._keys) {\r\n\t\tGame.textBuffer.clear();\r\n\r\n\t\tvar direction = this._keys[code];\r\n\t\tif (direction === -1) { /* noop */\r\n\t\t\t/* FIXME show something? */\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tvar dir = ROT.DIRS[8][direction];\r\n\t\tvar xy = this._xy.plus(new XY(dir[0], dir[1]));\r\n\r\n\t\tthis._level.setEntity(this, xy); /* FIXME collision detection */\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false; /* unknown key */\r\n}\r\n\r\nexport default Player;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/player.js","import XY from './xy'\r\n\r\nvar TextBuffer = function() {\r\n\tthis._data = [];\r\n\tthis._options = {\r\n\t\tdisplay: null,\r\n\t\tposition: new XY(),\r\n\t\tsize: new XY()\r\n\t}\r\n}\r\n\r\nTextBuffer.prototype.configure = function(options) {\r\n\tfor (var p in options) { this._options[p] = options[p]; }\r\n}\r\n\r\nTextBuffer.prototype.clear = function() {\r\n\tthis._data = [];\r\n}\r\n\r\nTextBuffer.prototype.write = function(text) {\r\n\tthis._data.push(text);\r\n}\r\n\r\nTextBuffer.prototype.flush = function() {\r\n\tvar o = this._options;\r\n\tvar d = o.display;\r\n\tvar pos = o.position;\r\n\tvar size = o.size;\r\n\r\n\t/* clear */\r\n\tfor (var i=0;i<size.x;i++) {\r\n\t\tfor (var j=0;j<size.y;j++) {\r\n\t\t\td.draw(pos.x+i, pos.y+j);\r\n\t\t}\r\n\t}\r\n\r\n\tvar text = this._data.join(\" \");\r\n\td.drawText(pos.x, pos.y, text, size.x);\r\n}\r\n\r\nexport default TextBuffer;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/textbuffer.js","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 13\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 14\n// module chunks = 0","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/rejection-tracking.js\n// module id = 16\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}